%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,french]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsfrench{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Simulation microprocesseur}
\date{avr. 15, 2020}
\release{1}
\author{Maxence Klein, Guillaume Desjouis, Véronique Reynaud}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Version}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{uPSimulator}
\label{\detokenize{modules:upsimulator}}\label{\detokenize{modules::doc}}

\section{arithmeticexpressionnodes module}
\label{\detokenize{arithmeticexpressionnodes:module-arithmeticexpressionnodes}}\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes-module}}\label{\detokenize{arithmeticexpressionnodes::doc}}\index{arithmeticexpressionnodes (module)@\spxentry{arithmeticexpressionnodes}\spxextra{module}}\phantomsection\label{\detokenize{arithmeticexpressionnodes:module-arithmeticexpressionnodes}}\index{arithmeticexpressionnodes (module)@\spxentry{arithmeticexpressionnodes}\spxextra{module}}
\begin{sphinxadmonition}{note}{Note:}
Les noeuds ne sont jamais modifiés. toute modification entraîne la création de clones.
\end{sphinxadmonition}
\index{ArithmeticExpressionNode (classe dans arithmeticexpressionnodes)@\spxentry{ArithmeticExpressionNode}\spxextra{classe dans arithmeticexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.}}\sphinxbfcode{\sphinxupquote{ArithmeticExpressionNode}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{clone() (méthode arithmeticexpressionnodes.ArithmeticExpressionNode)@\spxentry{clone()}\spxextra{méthode arithmeticexpressionnodes.ArithmeticExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ arithmeticexpressionnodes.ArithmeticExpressionNode}}
Fonction par défaut
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
l’objet lui\sphinxhyphen{}même

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{compile() (méthode arithmeticexpressionnodes.ArithmeticExpressionNode)@\spxentry{compile()}\spxextra{méthode arithmeticexpressionnodes.ArithmeticExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Exécute la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} ({\hyperref[\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CompileExpressionManager}}}}}) \textendash{} gestionnaire de compilation pour une expression

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode arithmeticexpressionnodes.ArithmeticExpressionNode)@\spxentry{getRegisterCost()}\spxextra{méthode arithmeticexpressionnodes.ArithmeticExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcule le nombre de registre nécessaire pour l’évaluation d’un noeud
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BinaryArithmeticNode (classe dans arithmeticexpressionnodes)@\spxentry{BinaryArithmeticNode}\spxextra{classe dans arithmeticexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.BinaryArithmeticNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.}}\sphinxbfcode{\sphinxupquote{BinaryArithmeticNode}}}{\emph{operator: str}, \emph{operand1: arithmeticexpressionnodes.ArithmeticExpressionNode}, \emph{operand2: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : {\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.ArithmeticExpressionNode}}}}}
\index{clone() (méthode arithmeticexpressionnodes.BinaryArithmeticNode)@\spxentry{clone()}\spxextra{méthode arithmeticexpressionnodes.BinaryArithmeticNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.BinaryArithmeticNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ arithmeticexpressionnodes.BinaryArithmeticNode}}
Produit un clone de l’objet avec son arborescence
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.BinaryArithmeticNode}]{\sphinxcrossref{BinaryArithmeticNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{compile() (méthode arithmeticexpressionnodes.BinaryArithmeticNode)@\spxentry{compile()}\spxextra{méthode arithmeticexpressionnodes.BinaryArithmeticNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.BinaryArithmeticNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Procédure d’exécution de la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} ({\hyperref[\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CompileExpressionManager}}}}}) \textendash{} objet prenant en charge la compilation d’une expression

\item[{Renvoie}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode arithmeticexpressionnodes.BinaryArithmeticNode)@\spxentry{getRegisterCost()}\spxextra{méthode arithmeticexpressionnodes.BinaryArithmeticNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.BinaryArithmeticNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcul du nombre de registre nécessaires pour évaluer ce noeud
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{engine}} ({\hyperref[\detokenize{processorengine:processorengine.ProcessorEngine}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ProcessorEngine}}}}}) \textendash{} modèle de processeur

\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral3} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd1} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd2} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{,} \PYG{n}{oLitteral3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oMult} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oAdd1}\PYG{p}{,} \PYG{n}{oAdd2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oMult}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12bits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral3} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd1} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd2} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{,} \PYG{n}{oLitteral3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oMult} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oAdd1}\PYG{p}{,} \PYG{n}{oAdd2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oMult}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{3}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{InverseNode (classe dans arithmeticexpressionnodes)@\spxentry{InverseNode}\spxextra{classe dans arithmeticexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.InverseNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.}}\sphinxbfcode{\sphinxupquote{InverseNode}}}{\emph{operand: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : {\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.ArithmeticExpressionNode}}}}}
\index{clone() (méthode arithmeticexpressionnodes.InverseNode)@\spxentry{clone()}\spxextra{méthode arithmeticexpressionnodes.InverseNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.InverseNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ arithmeticexpressionnodes.ArithmeticExpressionNode}}
Crée un noeud clone
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
UnaryNode

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’aborescence enfant est également clonée.
\end{sphinxadmonition}

\end{fulllineitems}

\index{compile() (méthode arithmeticexpressionnodes.InverseNode)@\spxentry{compile()}\spxextra{méthode arithmeticexpressionnodes.InverseNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.InverseNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Exécute la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} (\sphinxstyleliteralemphasis{\sphinxupquote{compileExpressionManager}}) \textendash{} gestionnaire de compilation pour une expression

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode arithmeticexpressionnodes.InverseNode)@\spxentry{getRegisterCost()}\spxextra{méthode arithmeticexpressionnodes.InverseNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.InverseNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcul le nombre de registre nécessaire pour l’évaluation d’un noeud
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’opérande étant placée dans un registre, on peut envisager de placer le résultat au même endroit.
L’opération ne nécessite alors pas de registres supplémentaire.
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{NegNode (classe dans arithmeticexpressionnodes)@\spxentry{NegNode}\spxextra{classe dans arithmeticexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.NegNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.}}\sphinxbfcode{\sphinxupquote{NegNode}}}{\emph{operand: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : {\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.ArithmeticExpressionNode}}}}}
\index{clone() (méthode arithmeticexpressionnodes.NegNode)@\spxentry{clone()}\spxextra{méthode arithmeticexpressionnodes.NegNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.NegNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ arithmeticexpressionnodes.ArithmeticExpressionNode}}
Crée un noeud clone
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
UnaryNode

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’aborescence enfant est également clonée.
\end{sphinxadmonition}

\end{fulllineitems}

\index{compile() (méthode arithmeticexpressionnodes.NegNode)@\spxentry{compile()}\spxextra{méthode arithmeticexpressionnodes.NegNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.NegNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Exécute la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} (\sphinxstyleliteralemphasis{\sphinxupquote{compileExpressionManager}}) \textendash{} gestionnaire de compilation pour une expression

\item[{Renvoie}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode arithmeticexpressionnodes.NegNode)@\spxentry{getRegisterCost()}\spxextra{méthode arithmeticexpressionnodes.NegNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.NegNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcul le nombre de registre nécessaire pour l’évaluation d’un noeud
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’opérande étant placée dans un registre, on peut envisager de placer le résultat au même endroit.
L’opération ne nécessite alors pas de registres supplémentaire.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oNeg} \PYG{o}{=} \PYG{n}{NegNode}\PYG{p}{(}\PYG{n}{oAdd}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oNeg}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12bits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oNeg} \PYG{o}{=} \PYG{n}{NegNode}\PYG{p}{(}\PYG{n}{oAdd}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oNeg}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{2}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ValueNode (classe dans arithmeticexpressionnodes)@\spxentry{ValueNode}\spxextra{classe dans arithmeticexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.}}\sphinxbfcode{\sphinxupquote{ValueNode}}}{\emph{value: Union{[}litteral.Litteral, variable.Variable{]}}}{}
Bases : {\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{arithmeticexpressionnodes.ArithmeticExpressionNode}}}}}
\index{clone() (méthode arithmeticexpressionnodes.ValueNode)@\spxentry{clone()}\spxextra{méthode arithmeticexpressionnodes.ValueNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ arithmeticexpressionnodes.ValueNode}}
Produit un clone de l’objet
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
BinaryNode

\end{description}\end{quote}

\end{fulllineitems}

\index{compile() (méthode arithmeticexpressionnodes.ValueNode)@\spxentry{compile()}\spxextra{méthode arithmeticexpressionnodes.ValueNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Procédure d’exécution de la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} ({\hyperref[\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CompileExpressionManager}}}}}) \textendash{} objet prenant en charge la compilation d’une expression

\item[{Renvoie}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode arithmeticexpressionnodes.ValueNode)@\spxentry{getRegisterCost()}\spxextra{méthode arithmeticexpressionnodes.ValueNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcule le nombre de registre nécessaire pour l’évaluation d’un noeud
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{1}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{value() (arithmeticexpressionnodes.ValueNode property)@\spxentry{value()}\spxextra{arithmeticexpressionnodes.ValueNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{Variable}}},{\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{Litteral}}}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{assembleurcontainer module}
\label{\detokenize{assembleurcontainer:module-assembleurcontainer}}\label{\detokenize{assembleurcontainer:assembleurcontainer-module}}\label{\detokenize{assembleurcontainer::doc}}\index{assembleurcontainer (module)@\spxentry{assembleurcontainer}\spxextra{module}}\phantomsection\label{\detokenize{assembleurcontainer:module-assembleurconainer}}\index{assembleurconainer (module)@\spxentry{assembleurconainer}\spxextra{module}}\index{AssembleurContainer (classe dans assembleurcontainer)@\spxentry{AssembleurContainer}\spxextra{classe dans assembleurcontainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{assembleurcontainer.}}\sphinxbfcode{\sphinxupquote{AssembleurContainer}}}{\emph{engine: processorengine.ProcessorEngine}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{getAsmSize() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getAsmSize()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getAsmSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getAsmSize}}}{}{{ $\rightarrow$ int}}
Calcule le nombre de lignes instructions.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de lignes

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{getBinary() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getBinary()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getBinary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getBinary}}}{}{{ $\rightarrow$ str}}
Produit le code binaire correspondant au code assembleur.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
code binaire

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getDecimal() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getDecimal()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getDecimal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getDecimal}}}{}{{ $\rightarrow$ List{[}int{]}}}
Produit une version int du code binaire.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
code assembleur sous forme d’une liste d’entier

\item[{Type renvoyé}] \leavevmode
List{[}int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLineLabel() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getLineLabel()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getLineLabel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLineLabel}}}{\emph{label: label.Label}}{{ $\rightarrow$ Optional{[}int{]}}}
Calcul l’adresse d’une étiquette.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{label}} ({\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}) \textendash{} étiquette recherchée

\item[{Renvoie}] \leavevmode
adresse de l’étiquette. None si elle n’est pas trouvée.

\item[{Type renvoyé}] \leavevmode
Union{[}int,None{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLineNumber() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getLineNumber()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getLineNumber}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLineNumber}}}{\emph{indexAsmLine: int}}{{ $\rightarrow$ int}}
index ligne asm \sphinxhyphen{}\textgreater{} index ligne origine
:param indexAsmLine: index ligne assembleur
:type indexAsmLine: int
:return: index ligne origine, \sphinxhyphen{}1 par défaut
:rtype: int

\end{fulllineitems}

\index{getMemAbsPos() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{getMemAbsPos()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.getMemAbsPos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getMemAbsPos}}}{\emph{item: variable.Variable}}{{ $\rightarrow$ Optional{[}int{]}}}
Calcule l’adresse mémoire d’une variable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{item}} ({\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Variable}}}}}) \textendash{} variable recherchée

\item[{Renvoie}] \leavevmode
adresse de la mémoire. None si elle n’est pas trouvée.

\item[{Type renvoyé}] \leavevmode
Union{[}int,None{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushCmp() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushCmp()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushCmp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushCmp}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, operand1: int, operand2: int}}{{ $\rightarrow$ None}}
Ajoute une commande CMP, comparaison, dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operand1}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre premier opérande

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operand2}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre second opérande

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Une telle commande doit précéder l’utilisation d’un saut conditionnel.
\end{sphinxadmonition}

\end{fulllineitems}

\index{pushHalt() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushHalt()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushHalt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushHalt}}}{\emph{label: Optional{[}label.Label{]}}}{{ $\rightarrow$ None}}
Ajoute une commande HALT, fin de programme, à l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\end{description}\end{quote}

\end{fulllineitems}

\index{pushInput() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushInput()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushInput}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, destination: variable.Variable}}{{ $\rightarrow$ None}}
Ajoute une commande INPUT, lecture entrée, dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} ({\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Variable}}}}}) \textendash{} variable cible

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushJump() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushJump()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushJump}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushJump}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, cible: label.Label, operator: Optional{[}str{]} = None}}{{ $\rightarrow$ None}}
Ajoute une commande JUMP, saut conditionnel ou non, dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cible}} ({\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}) \textendash{} étiquette cible

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str / None}}) \textendash{} comparaison parmi \textless{}, \textless{}=, \textgreater{}=, \textgreater{}, ==, !=. None pour Jump inconditionnel

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushLoad() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushLoad()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushLoad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushLoad}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, source: Union{[}variable.Variable, litteral.Litteral{]}, destination: int}}{{ $\rightarrow$ None}}
Ajoute une commande LOAD dans l’assembleur.

Réserve l’espace mémoire pour la source.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre destination

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{Litteral / Variable}}) \textendash{} variable ou littéral source

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushMove() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushMove()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushMove}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushMove}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, source: int, destination: int}}{{ $\rightarrow$ None}}
Ajoute une commande MOVE dans l’assembleur
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre destination

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre source

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushMoveLitteral() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushMoveLitteral()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushMoveLitteral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushMoveLitteral}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, source: litteral.Litteral, destination: int}}{{ $\rightarrow$ None}}
Ajoute une commande MOVE avec littéral dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre destination

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} ({\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}) \textendash{} littéral source

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushPrint() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushPrint()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushPrint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushPrint}}}{\emph{lineNumber: int}, \emph{source: int}}{{ $\rightarrow$ None}}
Ajoute une commande PRINT, affichage à l’écran, dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre dont on doit afficher le contenu

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushStore() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushStore()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushStore}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushStore}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, source: int, destination: variable.Variable}}{{ $\rightarrow$ None}}
Ajoute une commande STORE dans l’assembleur.

Réserve l’espace mémoire pour la variable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} ({\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Variable}}}}}) \textendash{} variable destination

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushUal() (méthode assembleurcontainer.AssembleurContainer)@\spxentry{pushUal()}\spxextra{méthode assembleurcontainer.AssembleurContainer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer.pushUal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushUal}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, operator: str, destination: int, regOperands: Tuple{[}int, ...{]}, littOperand: Optional{[}litteral.Litteral{]} = None}}{{ $\rightarrow$ None}}
Ajoute une commande de calcul UAL dans l’assembleur.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lineNumber}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de la ligne d’origine

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Label}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} label de l’instruction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{destination}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} registre destination

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} opérateur

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{regOperands}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} opérandes de type registre

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{littOperand}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} opérande de type littéral

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{assembleurlines module}
\label{\detokenize{assembleurlines:module-assembleurlines}}\label{\detokenize{assembleurlines:assembleurlines-module}}\label{\detokenize{assembleurlines::doc}}\index{assembleurlines (module)@\spxentry{assembleurlines}\spxextra{module}}\phantomsection\label{\detokenize{assembleurlines:module-assembleurlines}}\index{assembleurlines (module)@\spxentry{assembleurlines}\spxextra{module}}\index{AsmLine (classe dans assembleurlines)@\spxentry{AsmLine}\spxextra{classe dans assembleurlines}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{assembleurlines.}}\sphinxbfcode{\sphinxupquote{AsmLine}}}{\emph{lineNumber: int, label: Optional{[}label.Label{]}, opcode: str, asmCommand: str, regOperands: Tuple{[}int, ...{]}, specialOperand: Union{[}variable.Variable, label.Label, litteral.Litteral, None{]}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{getElementsToCode() (méthode assembleurlines.AsmLine)@\spxentry{getElementsToCode()}\spxextra{méthode assembleurlines.AsmLine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine.getElementsToCode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getElementsToCode}}}{}{{ $\rightarrow$ List{[}Union{[}int, str, label.Label, variable.Variable, litteral.Litteral{]}{]}}}
Retourne une liste d’éléments à coder
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
liste des éléments à coder

\item[{Type renvoyé}] \leavevmode
List{[}Union{[}int, str, {\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{Variable}}}, {\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{Litteral}}}{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLastOperandSize() (méthode assembleurlines.AsmLine)@\spxentry{getLastOperandSize()}\spxextra{méthode assembleurlines.AsmLine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine.getLastOperandSize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLastOperandSize}}}{\emph{wordSize: int}, \emph{regSize: int}}{{ $\rightarrow$ int}}
Retourne le nombre de bits laissés pour le codage binaire d’un éventuel dernier argument spécial (Litteral, Variable ou str pour label)
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wordSize}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} taille du mot en mémoire

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{regSize}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} taille des opérandes de type registre

\end{itemize}

\item[{Renvoie}] \leavevmode
nombre de bits laissés après les registres

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AsmLine}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1111}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLastOperandSize}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{6}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getSizeInMemory() (méthode assembleurlines.AsmLine)@\spxentry{getSizeInMemory()}\spxextra{méthode assembleurlines.AsmLine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine.getSizeInMemory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getSizeInMemory}}}{}{{ $\rightarrow$ int}}
Détermine  le nombre de lignes mémoires nécessaires pour cette ligne assembleur.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
1 pour ligne ordinaire

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AsmLine}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{111}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getSizeInMemory}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{label() (assembleurlines.AsmLine property)@\spxentry{label()}\spxextra{assembleurlines.AsmLine property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine.label}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{label}}}
Accesseur
:return: étiquette
:rtype: Label

\end{fulllineitems}

\index{lineNumber() (assembleurlines.AsmLine property)@\spxentry{lineNumber()}\spxextra{assembleurlines.AsmLine property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{assembleurlines:assembleurlines.AsmLine.lineNumber}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{lineNumber}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
numéro de la ligne d’origine

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AsmLine}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lab1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1111}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ADD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}\PYG{o}{.}\PYG{n}{lineNumber}
\PYG{g+go}{12}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{codeparser module}
\label{\detokenize{codeparser:module-codeparser}}\label{\detokenize{codeparser:codeparser-module}}\label{\detokenize{codeparser::doc}}\index{codeparser (module)@\spxentry{codeparser}\spxextra{module}}\phantomsection\label{\detokenize{codeparser:module-codeparser}}\index{codeparser (module)@\spxentry{codeparser}\spxextra{module}}\index{CodeParser (classe dans codeparser)@\spxentry{CodeParser}\spxextra{classe dans codeparser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{codeparser:codeparser.CodeParser}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{codeparser.}}\sphinxbfcode{\sphinxupquote{CodeParser}}}{\emph{**options}}{}
Bases : \sphinxcode{\sphinxupquote{object}}

Classe CodeParser
Parse le contenu d’un fichier passé en paramètre au constructeur
Une méthode public parseCode qui construit une liste d’objets LineParser avec organisation des enfants selon indentation
TODO \sphinxhyphen{} une méthode de contrôle de cohérence du code
ATTENTION \sphinxhyphen{} pas de gestion particulière du if, elif, else \sphinxhyphen{}\textgreater{} pas de tuple pour le noeud if et else \textendash{}\textgreater{} voir structureelements
\index{getFinalStructuredList() (méthode codeparser.CodeParser)@\spxentry{getFinalStructuredList()}\spxextra{méthode codeparser.CodeParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{codeparser:codeparser.CodeParser.getFinalStructuredList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getFinalStructuredList}}}{}{{ $\rightarrow$ List{[}structuresnodes.StructureNode{]}}}
\end{fulllineitems}

\index{parseCode() (méthode codeparser.CodeParser)@\spxentry{parseCode()}\spxextra{méthode codeparser.CodeParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{codeparser:codeparser.CodeParser.parseCode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parseCode}}}{\emph{lignesCode: List{[}str{]}}}{{ $\rightarrow$ None}}
\end{fulllineitems}


\end{fulllineitems}



\section{comparaisonexpressionnodes module}
\label{\detokenize{comparaisonexpressionnodes:module-comparaisonexpressionnodes}}\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes-module}}\label{\detokenize{comparaisonexpressionnodes::doc}}\index{comparaisonexpressionnodes (module)@\spxentry{comparaisonexpressionnodes}\spxextra{module}}\phantomsection\label{\detokenize{comparaisonexpressionnodes:module-comparaisonexpressionodes}}\index{comparaisonexpressionodes (module)@\spxentry{comparaisonexpressionodes}\spxextra{module}}
\begin{sphinxadmonition}{note}{Note:}
Les noeuds ne sont jamais modifiés. toute modification entraîne la création de clones.
\end{sphinxadmonition}
\index{ComparaisonExpressionNode (classe dans comparaisonexpressionnodes)@\spxentry{ComparaisonExpressionNode}\spxextra{classe dans comparaisonexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{comparaisonexpressionnodes.}}\sphinxbfcode{\sphinxupquote{ComparaisonExpressionNode}}}{\emph{operator: str}, \emph{operand1: arithmeticexpressionnodes.ArithmeticExpressionNode}, \emph{operand2: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{adjustConditionClone() (méthode comparaisonexpressionnodes.ComparaisonExpressionNode)@\spxentry{adjustConditionClone()}\spxextra{méthode comparaisonexpressionnodes.ComparaisonExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.adjustConditionClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adjustConditionClone}}}{\emph{csl: List{[}str{]}}}{{ $\rightarrow$ comparaisonexpressionnodes.ComparaisonExpressionNode}}
Ajustement des opérateurs de tests en fonction des symboles de comparaison disponibles
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{csl}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} symboles de comparaison disponibles

\item[{Renvoie}] \leavevmode
clone dont l’expression est adaptée

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}

\item[{Raises}] \leavevmode
AttributesErrors si aucun opérateur ne convient

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{variable} \PYG{k}{import} \PYG{n}{Variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oVariable} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral}\PYG{p}{,} \PYG{n}{oVariable}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp2} \PYG{o}{=} \PYG{n}{oComp}\PYG{o}{.}\PYG{n}{adjustConditionClone}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{oComp2}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}(@x \PYGZlt{} \PYGZsh{}4)\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{variable} \PYG{k}{import} \PYG{n}{Variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oVariable} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral}\PYG{p}{,} \PYG{n}{oVariable}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp2} \PYG{o}{=} \PYG{n}{oComp}\PYG{o}{.}\PYG{n}{adjustConditionClone}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{oComp2}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}not (\PYGZsh{}4 \PYGZlt{} @x)\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{clone() (méthode comparaisonexpressionnodes.ComparaisonExpressionNode)@\spxentry{clone()}\spxextra{méthode comparaisonexpressionnodes.ComparaisonExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ comparaisonexpressionnodes.ComparaisonExpressionNode}}
Produit un clone de l’objet avec son arborescence
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{comparaisonSymbol() (comparaisonexpressionnodes.ComparaisonExpressionNode property)@\spxentry{comparaisonSymbol()}\spxextra{comparaisonexpressionnodes.ComparaisonExpressionNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.comparaisonSymbol}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{comparaisonSymbol}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
symbole de comparaison

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{compile() (méthode comparaisonexpressionnodes.ComparaisonExpressionNode)@\spxentry{compile()}\spxextra{méthode comparaisonexpressionnodes.ComparaisonExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.compile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compile}}}{\emph{CEMObject: compileexpressionmanager.CompileExpressionManager}}{{ $\rightarrow$ None}}
Procédure d’exécution de la compilation
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CEMObject}} ({\hyperref[\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{CompileExpressionManager}}}}}) \textendash{} objet prenant en charge la compilation d’une expression

\end{description}\end{quote}

\end{fulllineitems}

\index{getRegisterCost() (méthode comparaisonexpressionnodes.ComparaisonExpressionNode)@\spxentry{getRegisterCost()}\spxextra{méthode comparaisonexpressionnodes.ComparaisonExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.getRegisterCost}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getRegisterCost}}}{\emph{engine: processorengine.ProcessorEngine}}{{ $\rightarrow$ int}}
Calcul du nombre de registre nécessaires pour évaluer ce noeud
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{engine}} ({\hyperref[\detokenize{processorengine:processorengine.ProcessorEngine}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ProcessorEngine}}}}}) \textendash{} modèle de processeur

\item[{Renvoie}] \leavevmode
nombre de registres

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}\PYG{p}{,} \PYG{n}{BinaryArithmeticNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral3} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd1} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd2} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{,} \PYG{n}{oLitteral3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oAdd1}\PYG{p}{,} \PYG{n}{oAdd2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{engine} \PYG{o}{=} \PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{12bits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}\PYG{p}{,} \PYG{n}{BinaryArithmeticNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral1} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral2} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral3} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd1} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral1}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oAdd2} \PYG{o}{=} \PYG{n}{BinaryArithmeticNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral2}\PYG{p}{,} \PYG{n}{oLitteral3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oAdd1}\PYG{p}{,} \PYG{n}{oAdd2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp}\PYG{o}{.}\PYG{n}{getRegisterCost}\PYG{p}{(}\PYG{n}{engine}\PYG{p}{)}
\PYG{g+go}{3}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{inversed() (comparaisonexpressionnodes.ComparaisonExpressionNode property)@\spxentry{inversed()}\spxextra{comparaisonexpressionnodes.ComparaisonExpressionNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.inversed}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{inversed}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
la comparaison doit être inversée

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{logicNegateClone() (méthode comparaisonexpressionnodes.ComparaisonExpressionNode)@\spxentry{logicNegateClone()}\spxextra{méthode comparaisonexpressionnodes.ComparaisonExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode.logicNegateClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logicNegateClone}}}{}{{ $\rightarrow$ comparaisonexpressionnodes.ComparaisonExpressionNode}}
Complément
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud dont les l’expression est complémentaire, ou le noeud lui même si pas de changement

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{variable} \PYG{k}{import} \PYG{n}{Variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oVariable} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral}\PYG{p}{,} \PYG{n}{oVariable}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp2} \PYG{o}{=} \PYG{n}{oComp}\PYG{o}{.}\PYG{n}{logicNegateClone}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{oComp2}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}not (\PYGZsh{}4 \PYGZgt{} @x)\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{compileexpressionmanager module}
\label{\detokenize{compileexpressionmanager:module-compileexpressionmanager}}\label{\detokenize{compileexpressionmanager:compileexpressionmanager-module}}\label{\detokenize{compileexpressionmanager::doc}}\index{compileexpressionmanager (module)@\spxentry{compileexpressionmanager}\spxextra{module}}\phantomsection\label{\detokenize{compileexpressionmanager:module-compileexpressionmanager}}\index{compileexpressionmanager (module)@\spxentry{compileexpressionmanager}\spxextra{module}}\index{CompileExpressionManager (classe dans compileexpressionmanager)@\spxentry{CompileExpressionManager}\spxextra{classe dans compileexpressionmanager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{compileexpressionmanager.}}\sphinxbfcode{\sphinxupquote{CompileExpressionManager}}}{\emph{engine: processorengine.ProcessorEngine, asmManager: assembleurcontainer.AssembleurContainer, lineNumber: int, label: Optional{[}label.Label{]}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{engine() (compileexpressionmanager.CompileExpressionManager property)@\spxentry{engine()}\spxextra{compileexpressionmanager.CompileExpressionManager property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.engine}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{engine}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
modèle de processeur utilisé

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{processorengine:processorengine.ProcessorEngine}]{\sphinxcrossref{ProcessorEngine}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getNeededRegisterSpace() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{getNeededRegisterSpace()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.getNeededRegisterSpace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getNeededRegisterSpace}}}{\emph{cost: int}, \emph{needUAL: bool}}{{ $\rightarrow$ None}}
Déplace des registres au besoin
* Déplace le registre 0 s’il est nécessaire pour l’UAL.
* Déplace les registres vers la mémoire autant que possible ou nécessaire
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} cout en registre du noeud d’opération nen cours

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{needUAL}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} le noeud nécessitera\sphinxhyphen{}t\sphinxhyphen{}il l’utilisation de l’UAL ?

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{getResultRegister() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{getResultRegister()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.getResultRegister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getResultRegister}}}{}{{ $\rightarrow$ int}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
registre en haut de la pile

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{pushBinaryOperator() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{pushBinaryOperator()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.pushBinaryOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushBinaryOperator}}}{\emph{operator: str}, \emph{directOrder: bool}}{{ $\rightarrow$ None}}
Ajoute une opération binaire.
Libère les 2 registres au sommet de la pile, ajoute l’opération,
Occupe le premier registre libre pour le résultat
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} opération parmi \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{/}}, \sphinxcode{\sphinxupquote{\%}}, \sphinxcode{\sphinxupquote{\&}}, \sphinxcode{\sphinxupquote{|}}, \sphinxcode{\sphinxupquote{\textasciicircum{}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{directOrder}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} vrai si le calcul est donné dans l’ordre, c’est à dire si le haut de la pile correspond au 2e opérande

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushBinaryOperatorWithLitteral() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{pushBinaryOperatorWithLitteral()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.pushBinaryOperatorWithLitteral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushBinaryOperatorWithLitteral}}}{\emph{operator: str}, \emph{litteral: litteral.Litteral}}{{ $\rightarrow$ None}}
Ajoute une opération binaire dont le 2e opérand est un littéral
Libère le registre au sommet de la pile comme 1er opérande.
Occupe le premier registre libre pour le résultat.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} opération parmi \sphinxcode{\sphinxupquote{+}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}, \sphinxcode{\sphinxupquote{*}}, \sphinxcode{\sphinxupquote{/}}, \sphinxcode{\sphinxupquote{\%}}, \sphinxcode{\sphinxupquote{\&}}, \sphinxcode{\sphinxupquote{|}}, \sphinxcode{\sphinxupquote{\textasciicircum{}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{litteral}} ({\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}) \textendash{} littéral

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushUnaryOperator() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{pushUnaryOperator()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.pushUnaryOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushUnaryOperator}}}{\emph{operator: str}}{{ $\rightarrow$ None}}
Ajoute une opération unaire
Libère le registre au sommet de la pile comme opérande.
Occupe le premier registre libre pour le résultat.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} opération parmi \sphinxcode{\sphinxupquote{\textasciitilde{}}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushUnaryOperatorWithLitteral() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{pushUnaryOperatorWithLitteral()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.pushUnaryOperatorWithLitteral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushUnaryOperatorWithLitteral}}}{\emph{operator: str}, \emph{litteral: litteral.Litteral}}{{ $\rightarrow$ None}}
Ajoute une opération unaire dont l’opérande est un littéral
Occupe le premier registre libre pour le résultat
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} opération parmi \sphinxcode{\sphinxupquote{\textasciitilde{}}}, \sphinxcode{\sphinxupquote{\sphinxhyphen{}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{litteral}} ({\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}) \textendash{} littéral

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{pushValue() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{pushValue()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.pushValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pushValue}}}{\emph{value: Union{[}litteral.Litteral, variable.Variable{]}}}{{ $\rightarrow$ None}}
Charge une valeur dans le premier registre disponible
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}{\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Variable}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} valeur à charger

\end{description}\end{quote}

\end{fulllineitems}

\index{resetMemory() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{resetMemory()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.resetMemory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resetMemory}}}{}{{ $\rightarrow$ None}}
Réinitialise les items mémoires du compilateur.

\end{fulllineitems}

\index{stringMemoryUsage() (méthode compileexpressionmanager.CompileExpressionManager)@\spxentry{stringMemoryUsage()}\spxextra{méthode compileexpressionmanager.CompileExpressionManager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compileexpressionmanager:compileexpressionmanager.CompileExpressionManager.stringMemoryUsage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stringMemoryUsage}}}{}{{ $\rightarrow$ str}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
représentation de l’occupation actuelle de la mémoire.

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{compilemanager module}
\label{\detokenize{compilemanager:module-compilemanager}}\label{\detokenize{compilemanager:compilemanager-module}}\label{\detokenize{compilemanager::doc}}\index{compilemanager (module)@\spxentry{compilemanager}\spxextra{module}}\phantomsection\label{\detokenize{compilemanager:module-compilemanager}}\index{compilemanager (module)@\spxentry{compilemanager}\spxextra{module}}\index{CompilationManager (classe dans compilemanager)@\spxentry{CompilationManager}\spxextra{classe dans compilemanager}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compilemanager:compilemanager.CompilationManager}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{compilemanager.}}\sphinxbfcode{\sphinxupquote{CompilationManager}}}{\emph{engine: processorengine.ProcessorEngine, listOfStructureNodes: List{[}structuresnodes.StructureNode{]}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{asm() (compilemanager.CompilationManager property)@\spxentry{asm()}\spxextra{compilemanager.CompilationManager property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{compilemanager:compilemanager.CompilationManager.asm}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{asm}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
objet assembleur contenant le résultat de la compilation

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{assembleurcontainer:assembleurcontainer.AssembleurContainer}]{\sphinxcrossref{AssembleurContainer}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{errors module}
\label{\detokenize{errors:module-errors}}\label{\detokenize{errors:errors-module}}\label{\detokenize{errors::doc}}\index{errors (module)@\spxentry{errors}\spxextra{module}}
Gestionnaire d’erreurs
\index{AttributesError@\spxentry{AttributesError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{errors:errors.AttributesError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{errors.}}\sphinxbfcode{\sphinxupquote{AttributesError}}}{\emph{message}, \emph{errors=None}}{}
Bases : \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{CompilationError@\spxentry{CompilationError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{errors:errors.CompilationError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{errors.}}\sphinxbfcode{\sphinxupquote{CompilationError}}}{\emph{message}, \emph{errors=None}}{}
Bases : \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{ExpressionError@\spxentry{ExpressionError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{errors:errors.ExpressionError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{errors.}}\sphinxbfcode{\sphinxupquote{ExpressionError}}}{\emph{message}, \emph{errors=None}}{}
Bases : \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}

\index{ParseError@\spxentry{ParseError}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{errors:errors.ParseError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{errors.}}\sphinxbfcode{\sphinxupquote{ParseError}}}{\emph{message}, \emph{errors=None}}{}
Bases : \sphinxcode{\sphinxupquote{Exception}}

\end{fulllineitems}



\section{example module}
\label{\detokenize{example:module-example}}\label{\detokenize{example:example-module}}\label{\detokenize{example::doc}}\index{example (module)@\spxentry{example}\spxextra{module}}\index{CompilationTest (classe dans example)@\spxentry{CompilationTest}\spxextra{classe dans example}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{example:example.CompilationTest}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{example.}}\sphinxbfcode{\sphinxupquote{CompilationTest}}}{\emph{methodName=\textquotesingle{}runTest\textquotesingle{}}}{}
Bases : \sphinxcode{\sphinxupquote{unittest.case.TestCase}}
\index{setUp() (méthode example.CompilationTest)@\spxentry{setUp()}\spxextra{méthode example.CompilationTest}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{example:example.CompilationTest.setUp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setUp}}}{}{}
Hook method for setting up the test fixture before exercising it.

\end{fulllineitems}

\index{test\_affectation\_12bits() (méthode example.CompilationTest)@\spxentry{test\_affectation\_12bits()}\spxextra{méthode example.CompilationTest}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{example:example.CompilationTest.test_affectation_12bits}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_affectation\_12bits}}}{}{}
\end{fulllineitems}

\index{test\_affectation\_16bits() (méthode example.CompilationTest)@\spxentry{test\_affectation\_16bits()}\spxextra{méthode example.CompilationTest}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{example:example.CompilationTest.test_affectation_16bits}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_affectation\_16bits}}}{}{}
\end{fulllineitems}

\index{test\_example\_1\_16bits() (méthode example.CompilationTest)@\spxentry{test\_example\_1\_16bits()}\spxextra{méthode example.CompilationTest}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{example:example.CompilationTest.test_example_1_16bits}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_example\_1\_16bits}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{executeur module}
\label{\detokenize{executeur:module-executeur}}\label{\detokenize{executeur:executeur-module}}\label{\detokenize{executeur::doc}}\index{executeur (module)@\spxentry{executeur}\spxextra{module}}\phantomsection\label{\detokenize{executeur:module-executeur}}\index{executeur (module)@\spxentry{executeur}\spxextra{module}}\index{Executeur (classe dans executeur)@\spxentry{Executeur}\spxextra{classe dans executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeur.}}\sphinxbfcode{\sphinxupquote{Executeur}}}{\emph{engine: processorengine.ProcessorEngine, binary: Union{[}List{[}int{]}, List{[}str{]}{]}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}

Identifiants des bus :
\sphinxhyphen{} DATA\_BUS : bus de données
\sphinxhyphen{} DATA\_BUS\_2 : bus secondaire entre les registres et la 2e opérande UAL

Identifiants des variables internes :
\sphinxhyphen{} MEMORY: mémoire
\sphinxhyphen{} MEMORY\_ADDRESS: registre adresse mémoire
\sphinxhyphen{} INSTRUCTION\_REGISTER: registre instruction
\sphinxhyphen{} LINE\_POINTER: registre pointeur de ligne
\sphinxhyphen{} PRINT: affichage
\sphinxhyphen{} BUFFER: buffer
\sphinxhyphen{} UAL: Unité Arithmétique et Logique
\sphinxhyphen{} REGISTERS\_OFFSET: registre 0
\index{BUFFER (attribut executeur.Executeur)@\spxentry{BUFFER}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.BUFFER}}\pysigline{\sphinxbfcode{\sphinxupquote{BUFFER}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{DATA\_BUS (attribut executeur.Executeur)@\spxentry{DATA\_BUS}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.DATA_BUS}}\pysigline{\sphinxbfcode{\sphinxupquote{DATA\_BUS}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{DATA\_BUS\_2 (attribut executeur.Executeur)@\spxentry{DATA\_BUS\_2}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.DATA_BUS_2}}\pysigline{\sphinxbfcode{\sphinxupquote{DATA\_BUS\_2}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{INSTRUCTION\_REGISTER (attribut executeur.Executeur)@\spxentry{INSTRUCTION\_REGISTER}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.INSTRUCTION_REGISTER}}\pysigline{\sphinxbfcode{\sphinxupquote{INSTRUCTION\_REGISTER}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{LINE\_POINTER (attribut executeur.Executeur)@\spxentry{LINE\_POINTER}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.LINE_POINTER}}\pysigline{\sphinxbfcode{\sphinxupquote{LINE\_POINTER}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{MEMORY (attribut executeur.Executeur)@\spxentry{MEMORY}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.MEMORY}}\pysigline{\sphinxbfcode{\sphinxupquote{MEMORY}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{MEMORY\_ADDRESS (attribut executeur.Executeur)@\spxentry{MEMORY\_ADDRESS}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.MEMORY_ADDRESS}}\pysigline{\sphinxbfcode{\sphinxupquote{MEMORY\_ADDRESS}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{PRINT (attribut executeur.Executeur)@\spxentry{PRINT}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.PRINT}}\pysigline{\sphinxbfcode{\sphinxupquote{PRINT}}\sphinxbfcode{\sphinxupquote{ = 4}}}
\end{fulllineitems}

\index{REGISTERS\_OFFSET (attribut executeur.Executeur)@\spxentry{REGISTERS\_OFFSET}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.REGISTERS_OFFSET}}\pysigline{\sphinxbfcode{\sphinxupquote{REGISTERS\_OFFSET}}\sphinxbfcode{\sphinxupquote{ = 7}}}
\end{fulllineitems}

\index{UAL (attribut executeur.Executeur)@\spxentry{UAL}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.UAL}}\pysigline{\sphinxbfcode{\sphinxupquote{UAL}}\sphinxbfcode{\sphinxupquote{ = 6}}}
\end{fulllineitems}

\index{bufferize() (méthode executeur.Executeur)@\spxentry{bufferize()}\spxextra{méthode executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.bufferize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bufferize}}}{\emph{value: int}}{{ $\rightarrow$ None}}
Ajoute un entier au buffer d’entrée
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} valeur à bufferiser

\end{description}\end{quote}

\end{fulllineitems}

\index{currentAsmLine (attribut executeur.Executeur)@\spxentry{currentAsmLine}\spxextra{attribut executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.currentAsmLine}}\pysigline{\sphinxbfcode{\sphinxupquote{currentAsmLine}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{getValue() (méthode executeur.Executeur)@\spxentry{getValue()}\spxextra{méthode executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.getValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getValue}}}{\emph{source: int}, \emph{silent=False}}{{ $\rightarrow$ Optional{[}int{]}}}
lit la valeur d’un variable interne du processeur virtuel
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{source}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} identifiant de la variable

\item[{Result}] \leavevmode
valeur de la variable ou False si l’identifiant est inconnu

\item[{Type renvoyé}] \leavevmode
Optional{[}int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{instructionStep() (méthode executeur.Executeur)@\spxentry{instructionStep()}\spxextra{méthode executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.instructionStep}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{instructionStep}}}{}{{ $\rightarrow$ int}}
Exécution d’une instruction complète.
Commande donc l’exécution de plusieurs step jusqu’à ce que currentState revienne à 0, \sphinxhyphen{}1 ou \sphinxhyphen{}2
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
état en cours.
\sphinxhyphen{}1 = halt
\sphinxhyphen{}2 = attente input
0 = début instruction,

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{nonStopRun() (méthode executeur.Executeur)@\spxentry{nonStopRun()}\spxextra{méthode executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.nonStopRun}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nonStopRun}}}{}{{ $\rightarrow$ int}}
Exécution du programme en continu
Commande donc l’exécution de plusieurs step jusqu’à ce que currentState revienne \sphinxhyphen{}1 ou \sphinxhyphen{}2
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
état en cours.
\sphinxhyphen{}1 = halt
\sphinxhyphen{}2 = attente input

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}
\begin{description}
\item[{..warning::}] \leavevmode
Si le programme boucle, l’instruction bouclera aussi.
De plus, ce programme prend la main pour toute une exécution.
Ne convient donc pas au cas d’une visualisation avec interface graphique devant se remettre à jour en parallèle de l’exécution.

\end{description}

\end{fulllineitems}

\index{step() (méthode executeur.Executeur)@\spxentry{step()}\spxextra{méthode executeur.Executeur}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step}}}{}{{ $\rightarrow$ int}}
Exécution d’un pas.
Il s’agit d’un pas élémentaire, il en faut plusieurs pour exécuter l’ensemble de l’instruction.
Le nombre de pas nécessaire dépend du type d’instruction.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
état en cours.
\sphinxhyphen{}1 = halt
\sphinxhyphen{}2 = attente input
0 = début instruction,
1 \textless{}= état interne du processeur correspondant au déroulement de l’instruction

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{waitingInput() (executeur.Executeur property)@\spxentry{waitingInput()}\spxextra{executeur.Executeur property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeur:executeur.Executeur.waitingInput}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{waitingInput}}}
Accesseur.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
processeur attend une entrée

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{executeurcomponents module}
\label{\detokenize{executeurcomponents:module-executeurcomponents}}\label{\detokenize{executeurcomponents:executeurcomponents-module}}\label{\detokenize{executeurcomponents::doc}}\index{executeurcomponents (module)@\spxentry{executeurcomponents}\spxextra{module}}\phantomsection\label{\detokenize{executeurcomponents:module-executeurcomponents}}\index{executeurcomponents (module)@\spxentry{executeurcomponents}\spxextra{module}}\index{BaseComponent (classe dans executeurcomponents)@\spxentry{BaseComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BaseComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{BaseComponent}}}{\emph{size: int}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{bind() (méthode executeurcomponents.BaseComponent)@\spxentry{bind()}\spxextra{méthode executeurcomponents.BaseComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BaseComponent.bind}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bind}}}{\emph{eventName: str, callback: Callable{[}{[}Dict{[}str, Union{[}str, int{]}{]}{]}, None{]}}}{}
Enregistre un événement
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eventName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de l’événement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{callback}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} fonction callback

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{size() (executeurcomponents.BaseComponent property)@\spxentry{size()}\spxextra{executeurcomponents.BaseComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BaseComponent.size}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{size}}}
\end{fulllineitems}

\index{trigger() (méthode executeurcomponents.BaseComponent)@\spxentry{trigger()}\spxextra{méthode executeurcomponents.BaseComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BaseComponent.trigger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{trigger}}}{\emph{eventName: str, params: Dict{[}str, Any{]}}}{{ $\rightarrow$ None}}
Déclenche un événement
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eventName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de l’événement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} paramètres empaquetés

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BufferComponent (classe dans executeurcomponents)@\spxentry{BufferComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BufferComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{BufferComponent}}}{\emph{size: int}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.BaseComponent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.BaseComponent}}}}}

Gestion du buffer d’entrée
\index{empty() (méthode executeurcomponents.BufferComponent)@\spxentry{empty()}\spxextra{méthode executeurcomponents.BufferComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BufferComponent.empty}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{empty}}}{}{{ $\rightarrow$ bool}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
True si le buffer est vide

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{list() (executeurcomponents.BufferComponent property)@\spxentry{list()}\spxextra{executeurcomponents.BufferComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BufferComponent.list}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{list}}}
Accesseur
:return: clone du contenu du buffer
:rtype: List{[}int{]}

\end{fulllineitems}

\index{read() (méthode executeurcomponents.BufferComponent)@\spxentry{read()}\spxextra{méthode executeurcomponents.BufferComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BufferComponent.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{{ $\rightarrow$ Union{[}executeurcomponents.DataValue, bool{]}}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
premier item du buffer s’il existe, sinon False

\item[{Type renvoyé}] \leavevmode
Union({\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}, bool)

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (méthode executeurcomponents.BufferComponent)@\spxentry{write()}\spxextra{méthode executeurcomponents.BufferComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.BufferComponent.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{value: int}}{{ $\rightarrow$ None}}~\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} valeur à ajouter dans le buffer

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{DataValue (classe dans executeurcomponents)@\spxentry{DataValue}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{DataValue}}}{\emph{size: int}, \emph{value: int = 0}}{}
Bases : \sphinxcode{\sphinxupquote{object}}

mot de donnée
\index{calc() (méthode executeurcomponents.DataValue)@\spxentry{calc()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.calc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calc}}}{\emph{otherValue: executeurcomponents.DataValue}, \emph{operation: str}}{{ $\rightarrow$ executeurcomponents.DataValue}}
calcule l’opération avec une autre valeur
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{otherValue}} ({\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}) \textendash{} autre valeur

\item[{Renvoie}] \leavevmode
résultat

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{clone() (méthode executeurcomponents.DataValue)@\spxentry{clone()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
\end{fulllineitems}

\index{inc() (méthode executeurcomponents.DataValue)@\spxentry{inc()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.inc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inc}}}{}{{ $\rightarrow$ None}}
incrémente la valeur tenant compte du codage CA2

\end{fulllineitems}

\index{intValue() (executeurcomponents.DataValue property)@\spxentry{intValue()}\spxextra{executeurcomponents.DataValue property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.intValue}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{intValue}}}
\end{fulllineitems}

\index{inverse() (méthode executeurcomponents.DataValue)@\spxentry{inverse()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.inverse}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inverse}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
calcul l’inverse d’un entier tenant compte du codage CA2
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
inverse de la valeur

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isNul() (méthode executeurcomponents.DataValue)@\spxentry{isNul()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.isNul}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isNul}}}{}{{ $\rightarrow$ bool}}
test si c’est entier nul
\begin{quote}\begin{description}
\item[{Result}] \leavevmode
la valeur est nulle

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{isPos() (méthode executeurcomponents.DataValue)@\spxentry{isPos()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.isPos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isPos}}}{}{{ $\rightarrow$ bool}}
test si c’est entier est positif (en CA2, tenant compte de la base)
\begin{quote}\begin{description}
\item[{Result}] \leavevmode
la valeur est positive (ou nulle)

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{mask() (méthode executeurcomponents.DataValue)@\spxentry{mask()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.mask}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mask}}}{\emph{mask: int}}{{ $\rightarrow$ executeurcomponents.DataValue}}
Calcule le résultat de la valeur masquée
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mask}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} masque

\item[{Renvoie}] \leavevmode
valeur masquée

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{opposite() (méthode executeurcomponents.DataValue)@\spxentry{opposite()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.opposite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{opposite}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
calcul l’opposé d’un entier tenant compte du codage CA2
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
oppposé de la valeur

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{toSignInt() (méthode executeurcomponents.DataValue)@\spxentry{toSignInt()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.toSignInt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toSignInt}}}{}{{ $\rightarrow$ int}}
transtypage en int tenant compte de l’éventel signe CA2
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur courante

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{toStr() (méthode executeurcomponents.DataValue)@\spxentry{toStr()}\spxextra{méthode executeurcomponents.DataValue}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.DataValue.toStr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toStr}}}{\emph{base: str = \textquotesingle{}bin\textquotesingle{}}}{{ $\rightarrow$ str}}
transtypage tenant compte que value n’est pas forcément sur 32 bits
comme les int ordinaire de python pour lesquels str() est conçu
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{base}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} base de l’écriture parmi “bin”, “hex”, “dec”, “udec”

\item[{Result}] \leavevmode
valeur sous forme str

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{MemoryComponent (classe dans executeurcomponents)@\spxentry{MemoryComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{MemoryComponent}}}{\emph{size: int}, \emph{initialValues: List{[}Union{[}str}, \emph{int{]}{]} = {[}{]}}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.RegisterGroup}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.RegisterGroup}}}}}

Gestion de la mémoire
équivalent à RegisterGroup avec adresseRegister en plus
\index{address() (executeurcomponents.MemoryComponent property)@\spxentry{address()}\spxextra{executeurcomponents.MemoryComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent.address}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{address}}}
\end{fulllineitems}

\index{incAddressedRegister() (méthode executeurcomponents.MemoryComponent)@\spxentry{incAddressedRegister()}\spxextra{méthode executeurcomponents.MemoryComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent.incAddressedRegister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{incAddressedRegister}}}{}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{readAddressedRegister() (méthode executeurcomponents.MemoryComponent)@\spxentry{readAddressedRegister()}\spxextra{méthode executeurcomponents.MemoryComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent.readAddressedRegister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{readAddressedRegister}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
\end{fulllineitems}

\index{setAddress() (méthode executeurcomponents.MemoryComponent)@\spxentry{setAddress()}\spxextra{méthode executeurcomponents.MemoryComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent.setAddress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setAddress}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
\end{fulllineitems}

\index{writeAddressedRegister() (méthode executeurcomponents.MemoryComponent)@\spxentry{writeAddressedRegister()}\spxextra{méthode executeurcomponents.MemoryComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.MemoryComponent.writeAddressedRegister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeAddressedRegister}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
\end{fulllineitems}


\end{fulllineitems}

\index{RegisterComponent (classe dans executeurcomponents)@\spxentry{RegisterComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{RegisterComponent}}}{\emph{name: str}, \emph{size: int}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.BaseComponent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.BaseComponent}}}}}

Gestion d’un registre
\index{inc() (méthode executeurcomponents.RegisterComponent)@\spxentry{inc()}\spxextra{méthode executeurcomponents.RegisterComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent.inc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inc}}}{}{{ $\rightarrow$ None}}
incrémente la valeur du registre

\end{fulllineitems}

\index{intValue() (executeurcomponents.RegisterComponent property)@\spxentry{intValue()}\spxextra{executeurcomponents.RegisterComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent.intValue}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{intValue}}}
\end{fulllineitems}

\index{name() (executeurcomponents.RegisterComponent property)@\spxentry{name()}\spxextra{executeurcomponents.RegisterComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nom du registre

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (méthode executeurcomponents.RegisterComponent)@\spxentry{read()}\spxextra{méthode executeurcomponents.RegisterComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
lecture de value
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur courante du registre

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (méthode executeurcomponents.RegisterComponent)@\spxentry{write()}\spxextra{méthode executeurcomponents.RegisterComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterComponent.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
écrit la valeur dans le registre
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} ajoute valeur à l’écran

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RegisterGroup (classe dans executeurcomponents)@\spxentry{RegisterGroup}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterGroup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{RegisterGroup}}}{\emph{registerNumber: int}, \emph{size: int}, \emph{initialValues: List{[}int{]} = {[}{]}}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.BaseComponent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.BaseComponent}}}}}

Gestion d’un groupe de registres
\index{content() (executeurcomponents.RegisterGroup property)@\spxentry{content()}\spxextra{executeurcomponents.RegisterGroup property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterGroup.content}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{content}}}
\end{fulllineitems}

\index{inc() (méthode executeurcomponents.RegisterGroup)@\spxentry{inc()}\spxextra{méthode executeurcomponents.RegisterGroup}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterGroup.inc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inc}}}{\emph{index: int}}{{ $\rightarrow$ None}}
incrémente la valeur du registre
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} indice du registre incrémenté

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (méthode executeurcomponents.RegisterGroup)@\spxentry{read()}\spxextra{méthode executeurcomponents.RegisterGroup}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterGroup.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{\emph{index: int}}{{ $\rightarrow$ Optional{[}executeurcomponents.DataValue{]}}}
lecture de la valeur du registre d’index n
:param index: indice du registre lu
:type index: int
:return: valeur courante du registre. \sphinxhyphen{}1 par défaut
:rtype: int

\end{fulllineitems}

\index{write() (méthode executeurcomponents.RegisterGroup)@\spxentry{write()}\spxextra{méthode executeurcomponents.RegisterGroup}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.RegisterGroup.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{index: int, value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
écrit la valeur dans le registre
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} indice du registre écrit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} écrit la valeur dans le registre

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ScreenComponent (classe dans executeurcomponents)@\spxentry{ScreenComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.ScreenComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{ScreenComponent}}}{\emph{size}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.BaseComponent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.BaseComponent}}}}}

Gestion de l’écran
\index{clear() (méthode executeurcomponents.ScreenComponent)@\spxentry{clear()}\spxextra{méthode executeurcomponents.ScreenComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.ScreenComponent.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Efface le contenu

\end{fulllineitems}

\index{empty() (méthode executeurcomponents.ScreenComponent)@\spxentry{empty()}\spxextra{méthode executeurcomponents.ScreenComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.ScreenComponent.empty}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{empty}}}{}{{ $\rightarrow$ bool}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
True si le buffer est vide

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{getStringList() (méthode executeurcomponents.ScreenComponent)@\spxentry{getStringList()}\spxextra{méthode executeurcomponents.ScreenComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.ScreenComponent.getStringList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getStringList}}}{\emph{base: str = \textquotesingle{}bin\textquotesingle{}}}{{ $\rightarrow$ List{[}str{]}}}~\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{base}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} base de la lecture, parmi “bin”, “dec”, “hex”, “udec”

\item[{Renvoie}] \leavevmode
liste du contenu de l’écran

\item[{Type renvoyé}] \leavevmode
List{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (méthode executeurcomponents.ScreenComponent)@\spxentry{write()}\spxextra{méthode executeurcomponents.ScreenComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.ScreenComponent.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}~\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} ajoute valeur à l’écran

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{UalComponent (classe dans executeurcomponents)@\spxentry{UalComponent}\spxextra{classe dans executeurcomponents}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{executeurcomponents.}}\sphinxbfcode{\sphinxupquote{UalComponent}}}{\emph{size: int}}{}
Bases : {\hyperref[\detokenize{executeurcomponents:executeurcomponents.BaseComponent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{executeurcomponents.BaseComponent}}}}}

Gestion de l’Unité Arithmétique et Logique
\index{execCalc() (méthode executeurcomponents.UalComponent)@\spxentry{execCalc()}\spxextra{méthode executeurcomponents.UalComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.execCalc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{execCalc}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
exécute le calcul
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur du résultat

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{isPos() (executeurcomponents.UalComponent property)@\spxentry{isPos()}\spxextra{executeurcomponents.UalComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.isPos}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{isPos}}}
\end{fulllineitems}

\index{isZero() (executeurcomponents.UalComponent property)@\spxentry{isZero()}\spxextra{executeurcomponents.UalComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.isZero}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{isZero}}}
\end{fulllineitems}

\index{op1() (executeurcomponents.UalComponent property)@\spxentry{op1()}\spxextra{executeurcomponents.UalComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.op1}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{op1}}}
\end{fulllineitems}

\index{op2() (executeurcomponents.UalComponent property)@\spxentry{op2()}\spxextra{executeurcomponents.UalComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.op2}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{op2}}}
\end{fulllineitems}

\index{operation() (executeurcomponents.UalComponent property)@\spxentry{operation()}\spxextra{executeurcomponents.UalComponent property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.operation}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operation}}}
\end{fulllineitems}

\index{read() (méthode executeurcomponents.UalComponent)@\spxentry{read()}\spxextra{méthode executeurcomponents.UalComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{}{{ $\rightarrow$ executeurcomponents.DataValue}}
lit le résultat
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
résultat du dernier calcul

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{DataValue}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{setOperation() (méthode executeurcomponents.UalComponent)@\spxentry{setOperation()}\spxextra{méthode executeurcomponents.UalComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.setOperation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setOperation}}}{\emph{opName: str}}{{ $\rightarrow$ None}}
Fixe l’opération
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{opName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} opération parmi neg, \textasciitilde{}, +, \sphinxhyphen{}, {\color{red}\bfseries{}*}, /, \%, \&, {\color{red}\bfseries{}|}, \textasciicircum{}

\end{description}\end{quote}

\end{fulllineitems}

\index{writeFirstOperand() (méthode executeurcomponents.UalComponent)@\spxentry{writeFirstOperand()}\spxextra{méthode executeurcomponents.UalComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.writeFirstOperand}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeFirstOperand}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
Fixe l’opérande 1
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} valeur de l’opérande

\end{description}\end{quote}

\end{fulllineitems}

\index{writeSecondOperand() (méthode executeurcomponents.UalComponent)@\spxentry{writeSecondOperand()}\spxextra{méthode executeurcomponents.UalComponent}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{executeurcomponents:executeurcomponents.UalComponent.writeSecondOperand}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeSecondOperand}}}{\emph{value: Union{[}executeurcomponents.DataValue, int{]}}}{{ $\rightarrow$ None}}
Fixe l’opérande 2
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} valeur de l’opérande

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{expressionparser module}
\label{\detokenize{expressionparser:module-expressionparser}}\label{\detokenize{expressionparser:expressionparser-module}}\label{\detokenize{expressionparser::doc}}\index{expressionparser (module)@\spxentry{expressionparser}\spxextra{module}}\phantomsection\label{\detokenize{expressionparser:module-expressionparser}}\index{expressionparser (module)@\spxentry{expressionparser}\spxextra{module}}\index{ExpressionParser (classe dans expressionparser)@\spxentry{ExpressionParser}\spxextra{classe dans expressionparser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{expressionparser.}}\sphinxbfcode{\sphinxupquote{ExpressionParser}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{TokensList (attribut expressionparser.ExpressionParser)@\spxentry{TokensList}\spxextra{attribut expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.TokensList}}\pysigline{\sphinxbfcode{\sphinxupquote{TokensList}}\sphinxbfcode{\sphinxupquote{ = {[}\textless{}class \textquotesingle{}parsertokens.TokenVariable\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}parsertokens.TokenNumber\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}parsertokens.TokenBinaryOperator\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}parsertokens.TokenUnaryOperator\textquotesingle{}\textgreater{}, \textless{}class \textquotesingle{}parsertokens.TokenParenthesis\textquotesingle{}\textgreater{}{]}}}}
\end{fulllineitems}

\index{buildExpression() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{buildExpression()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.buildExpression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{buildExpression}}}{\emph{originalExpression: str}}{{ $\rightarrow$ Union{[}arithmeticexpressionnodes.ArithmeticExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}}}
À partir d’une expression sous forme d’une chaîne de texte, produit l’arbre représentant cette expression et retourne la racine de cet arbre.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{originalExpression}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} expression à analyser

\item[{Renvoie}] \leavevmode
racine de l’arbre

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}{]}

\item[{Raises}] \leavevmode
ExpressionError si l’expression ne match pas l’expression régulière ou si les parenthèses ne sont pas convenablement équilibrées, ou si l’expression contient un enchaînement non valable, comme +).

\end{description}\end{quote}

\end{fulllineitems}

\index{expressionRegex() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{expressionRegex()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.expressionRegex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{expressionRegex}}}{}{{ $\rightarrow$ str}}
Donne accès à l’expression régulière d’une expression
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression régulière d’une expression

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{isLegal() (méthode statique expressionparser.ExpressionParser)@\spxentry{isLegal()}\spxextra{méthode statique expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.isLegal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{isLegal}}}{\emph{precedent}, \emph{suivant}}{}
Test si l’enchaînement de deux Token est possible. Par exemple “*” ne peut pas suivre “(“
\begin{itemize}
\item {} 
un opérateur binaire ne peut être en première ou dernière place

\item {} 
“)” ne peut être en premier ni “(“ à la fin

\item {} 
deux opérateurs binaires ne peuvent pas se suivre

\item {} 
un opérateur binaire ne peut pas suivre “(“ ou précéder “)”

\item {} 
une opérande (nombre/variable) ne peut précéder un opérateur unaire

\item {} 
deux opérandes ne peuvent se suivre

\item {} 
deux parenthèses différentes ne peuvent se suivre : “()” et “)(“ interdits

\end{itemize}
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai si l’enchaînement est possible

\item[{Type renvoyé}] \leavevmode
bool

\item[{Exemple}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{isLegal}\PYG{p}{(}\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{isLegal}\PYG{p}{(}\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{isLegal}\PYG{p}{(}\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{TokenUnaryOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{isLegal}\PYG{p}{(}\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{regex() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{regex()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.regex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{regex}}}{}{{ $\rightarrow$ str}}
Concatène les expressions régulière pour les différents constituants d’une expression
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression régulière d’un item d’expression

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{strIsExpression() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{strIsExpression()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.strIsExpression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{strIsExpression}}}{\emph{expression: str}}{{ $\rightarrow$ bool}}
Teste si une chaîne de caractères est une expression possible.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{expression}} \textendash{} expression à tester

\item[{Renvoie}] \leavevmode
vrai si l’expression est valable

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{strIsExpression}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{45x\PYGZhy{}3zdf = dz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{strIsExpression}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{45*x\PYGZhy{}3+zdf \PYGZhy{} dz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{strIsVariableName() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{strIsVariableName()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.strIsVariableName}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{strIsVariableName}}}{\emph{nomVariable: str}}{{ $\rightarrow$ bool}}
Teste si une chaîne de caractères est un nom de variable possible.

Exclut les mots\sphinxhyphen{}clefs du langage
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{expression}} \textendash{} expression à tester

\item[{Renvoie}] \leavevmode
vrai si le nom est valable

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{testBrackets() (méthode statique expressionparser.ExpressionParser)@\spxentry{testBrackets()}\spxextra{méthode statique expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.testBrackets}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{testBrackets}}}{\emph{expression}}{{ $\rightarrow$ bool}}
Test l’équilibre des parenthèses
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai si les parenthèses sont équilibrées

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{testBrackets}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4*x \PYGZhy{} ((3 + 2) + 4)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{testBrackets}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{( ( ( ) ) }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{testBrackets}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{( ( ) ) ) }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ExpressionParser}\PYG{o}{.}\PYG{n}{testBrackets}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{( ) ) (}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{variableRegex() (méthode de la classe expressionparser.ExpressionParser)@\spxentry{variableRegex()}\spxextra{méthode de la classe expressionparser.ExpressionParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{expressionparser:expressionparser.ExpressionParser.variableRegex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{variableRegex}}}{}{{ $\rightarrow$ str}}
Donne accès à l’expression régulière d’une variable
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression régulière d’une variable

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{graphic module}
\label{\detokenize{graphic:module-graphic}}\label{\detokenize{graphic:graphic-module}}\label{\detokenize{graphic::doc}}\index{graphic (module)@\spxentry{graphic}\spxextra{module}}\phantomsection\label{\detokenize{graphic:module-graphic}}\index{graphic (module)@\spxentry{graphic}\spxextra{module}}\index{InputCodeWindow (classe dans graphic)@\spxentry{InputCodeWindow}\spxextra{classe dans graphic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{graphic.}}\sphinxbfcode{\sphinxupquote{InputCodeWindow}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{BIN\_DISPLAY (attribut graphic.InputCodeWindow)@\spxentry{BIN\_DISPLAY}\spxextra{attribut graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.BIN_DISPLAY}}\pysigline{\sphinxbfcode{\sphinxupquote{BIN\_DISPLAY}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{DEC\_DISPLAY (attribut graphic.InputCodeWindow)@\spxentry{DEC\_DISPLAY}\spxextra{attribut graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.DEC_DISPLAY}}\pysigline{\sphinxbfcode{\sphinxupquote{DEC\_DISPLAY}}\sphinxbfcode{\sphinxupquote{ = 1}}}
\end{fulllineitems}

\index{EXEMPLES (attribut graphic.InputCodeWindow)@\spxentry{EXEMPLES}\spxextra{attribut graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.EXEMPLES}}\pysigline{\sphinxbfcode{\sphinxupquote{EXEMPLES}}\sphinxbfcode{\sphinxupquote{ = {[}(\textquotesingle{}exemple 1\textquotesingle{}, \textquotesingle{}example.code\textquotesingle{}), (\textquotesingle{}exemple 2\textquotesingle{}, \textquotesingle{}example2.code\textquotesingle{}), (\textquotesingle{}exemple 3\textquotesingle{}, \textquotesingle{}example3.code\textquotesingle{}){]}}}}
\end{fulllineitems}

\index{HEX\_DISPLAY (attribut graphic.InputCodeWindow)@\spxentry{HEX\_DISPLAY}\spxextra{attribut graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.HEX_DISPLAY}}\pysigline{\sphinxbfcode{\sphinxupquote{HEX\_DISPLAY}}\sphinxbfcode{\sphinxupquote{ = 2}}}
\end{fulllineitems}

\index{MODES (attribut graphic.InputCodeWindow)@\spxentry{MODES}\spxextra{attribut graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}dec\textquotesingle{}, \textquotesingle{}hex\textquotesingle{})}}}
\end{fulllineitems}

\index{addMessage() (méthode graphic.InputCodeWindow)@\spxentry{addMessage()}\spxextra{méthode graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.addMessage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addMessage}}}{\emph{message}}{}
\end{fulllineitems}

\index{inEditMode() (méthode graphic.InputCodeWindow)@\spxentry{inEditMode()}\spxextra{méthode graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.inEditMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inEditMode}}}{}{}
\end{fulllineitems}

\index{show() (méthode graphic.InputCodeWindow)@\spxentry{show()}\spxextra{méthode graphic.InputCodeWindow}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{graphic:graphic.InputCodeWindow.show}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{show}}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\section{label module}
\label{\detokenize{label:module-label}}\label{\detokenize{label:label-module}}\label{\detokenize{label::doc}}\index{label (module)@\spxentry{label}\spxextra{module}}\phantomsection\label{\detokenize{label:module-label}}\index{label (module)@\spxentry{label}\spxextra{module}}\index{Label (classe dans label)@\spxentry{Label}\spxextra{classe dans label}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{label:label.Label}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{label.}}\sphinxbfcode{\sphinxupquote{Label}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{PREFIX (attribut label.Label)@\spxentry{PREFIX}\spxextra{attribut label.Label}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{label:label.Label.PREFIX}}\pysigline{\sphinxbfcode{\sphinxupquote{PREFIX}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}Lab\textquotesingle{}}}}
\end{fulllineitems}

\index{getNextFreeIndex() (méthode de la classe label.Label)@\spxentry{getNextFreeIndex()}\spxextra{méthode de la classe label.Label}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{label:label.Label.getNextFreeIndex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{getNextFreeIndex}}}{}{{ $\rightarrow$ int}}
génère un nouvel index de numéro de label. Assure l’unicité des numéros.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
index pour in nouveau label

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{name() (label.Label property)@\spxentry{name()}\spxextra{label.Label property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{label:label.Label.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Assigne le nom si nécessaire et le retourne
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nom de l’étiquette

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{lineparser module}
\label{\detokenize{lineparser:module-lineparser}}\label{\detokenize{lineparser:lineparser-module}}\label{\detokenize{lineparser::doc}}\index{lineparser (module)@\spxentry{lineparser}\spxextra{module}}\phantomsection\label{\detokenize{lineparser:module-lineparser}}\index{lineparser (module)@\spxentry{lineparser}\spxextra{module}}\index{Caracteristiques (classe dans lineparser)@\spxentry{Caracteristiques}\spxextra{classe dans lineparser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{lineparser:lineparser.Caracteristiques}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{lineparser.}}\sphinxbfcode{\sphinxupquote{Caracteristiques}}}
Bases : \sphinxcode{\sphinxupquote{dict}}

\end{fulllineitems}

\index{LineParser (classe dans lineparser)@\spxentry{LineParser}\spxextra{classe dans lineparser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{lineparser:lineparser.LineParser}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{lineparser.}}\sphinxbfcode{\sphinxupquote{LineParser}}}{\emph{originalLine: str}, \emph{lineNumber: int}}{}
Bases : \sphinxcode{\sphinxupquote{object}}

Classe LineParser
Une ligne qui passe par LineParser :
.\_\_originalLine (contient la ligne d’origine)
.\_\_cleanLine (contient la ligne épurée des commentaires et des éventuels espaces en fin de ligne)
.\_\_caracteristiques dictonnaire
\begin{quote}

lineNumber  : contient le n° de ligne traitée, passé en paramètre au constructeur
indentation : contient le nombre d’espace pour l’indentation
emptyLine   : True si ligne est vide, False sinon
type        : correspond au motif identifié (if, elif, while, else, print, input, affectation)
condition   : contient un objet LogicExpressionNode ou ComparaisonExpressionNode pour les motifs attendant une condition
expression  : contient un objet ArithmeticExpressionNode s’il s’agit d’une affectation ou d’un print
variable    : contient un objet Variable s’il s’agit d’une affectation ou d’un input
\end{quote}

Une méthode getCaracs() pour retourne le dictionnaire \_\_caracteristiques
\index{getCaracs() (méthode lineparser.LineParser)@\spxentry{getCaracs()}\spxextra{méthode lineparser.LineParser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{lineparser:lineparser.LineParser.getCaracs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getCaracs}}}{}{{ $\rightarrow$ lineparser.Caracteristiques}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
caractéristiques de la ligne

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{lineparser:lineparser.Caracteristiques}]{\sphinxcrossref{Caracteristiques}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{linkedlistnode module}
\label{\detokenize{linkedlistnode:module-linkedlistnode}}\label{\detokenize{linkedlistnode:linkedlistnode-module}}\label{\detokenize{linkedlistnode::doc}}\index{linkedlistnode (module)@\spxentry{linkedlistnode}\spxextra{module}}\phantomsection\label{\detokenize{linkedlistnode:module-linkedlistnode}}\index{linkedlistnode (module)@\spxentry{linkedlistnode}\spxextra{module}}\index{LinkedList (classe dans linkedlistnode)@\spxentry{LinkedList}\spxextra{classe dans linkedlistnode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{linkedlistnode.}}\sphinxbfcode{\sphinxupquote{LinkedList}}}{\emph{items: List{[}LinkedListNode{]}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{append() (méthode linkedlistnode.LinkedList)@\spxentry{append()}\spxextra{méthode linkedlistnode.LinkedList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.append}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append}}}{\emph{listToAppend: Union{[}LinkedListNode, LinkedList{]}}}{{ $\rightarrow$ None}}
ajoute le contenu de listToAppend à la suite, listToAppend s’en trouve vidée
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{listToAppend}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}LinkedListNode\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}LinkedList\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} liste à ajouter

\end{description}\end{quote}

\end{fulllineitems}

\index{delete() (méthode linkedlistnode.LinkedList)@\spxentry{delete()}\spxextra{méthode linkedlistnode.LinkedList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{\emph{nodeToDel: linkedlistnode.LinkedListNode}}{{ $\rightarrow$ bool}}
supprime l’élément node
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{nodeToDel}} ({\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LinkedListNode}}}}}) \textendash{} élément à supprimer

\item[{Renvoie}] \leavevmode
suppression effectuée

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{has() (méthode linkedlistnode.LinkedList)@\spxentry{has()}\spxextra{méthode linkedlistnode.LinkedList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.has}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has}}}{\emph{nodeToSearch: linkedlistnode.LinkedListNode}}{{ $\rightarrow$ bool}}~\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{nodeToSearch}} ({\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LinkedListNode}}}}}) \textendash{} noeud cherché

\item[{Renvoie}] \leavevmode
la liste contient le noeud

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{head() (linkedlistnode.LinkedList property)@\spxentry{head()}\spxextra{linkedlistnode.LinkedList property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.head}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{head}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
pointeur sur la tête

\item[{Type renvoyé}] \leavevmode
Optional{[}« LinkedListNode »{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{length() (linkedlistnode.LinkedList property)@\spxentry{length()}\spxextra{linkedlistnode.LinkedList property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.length}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{length}}}
propriété
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre d’item de la liste

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{replace() (méthode linkedlistnode.LinkedList)@\spxentry{replace()}\spxextra{méthode linkedlistnode.LinkedList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.replace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{replace}}}{\emph{nodeToReplace: linkedlistnode.LinkedListNode, listToInsert: Union{[}LinkedList, LinkedListNode{]}}}{{ $\rightarrow$ linkedlistnode.LinkedList}}
remplace l’élément par une liste
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nodeToReplace}} ({\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LinkedListNode}}}}}) \textendash{} noeud à remplacer

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{listToInsert}} \textendash{} liste à insérer à la place

\end{itemize}

\item[{Type}] \leavevmode
Union{[}« LinkedList », « LinkedListNode »{]}

\item[{Renvoie}] \leavevmode
liste ayant subit l’insertion

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedList}]{\sphinxcrossref{LinkedList}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{toList() (méthode linkedlistnode.LinkedList)@\spxentry{toList()}\spxextra{méthode linkedlistnode.LinkedList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedList.toList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toList}}}{}{{ $\rightarrow$ List{[}linkedlistnode.LinkedListNode{]}}}
Produit une liste des items enfants
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
liste des noeuds

\item[{Type renvoyé}] \leavevmode
List{[}{\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{LinkedListNode}}}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LinkedListNode (classe dans linkedlistnode)@\spxentry{LinkedListNode}\spxextra{classe dans linkedlistnode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{linkedlistnode.}}\sphinxbfcode{\sphinxupquote{LinkedListNode}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{insertLeft() (méthode linkedlistnode.LinkedListNode)@\spxentry{insertLeft()}\spxextra{méthode linkedlistnode.LinkedListNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedListNode.insertLeft}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insertLeft}}}{\emph{toInsert: Union{[}LinkedList, LinkedListNode{]}}}{{ $\rightarrow$ linkedlistnode.LinkedListNode}}
Insert un noeud ou tout une chaîne à gauche
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{toInsert}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{"LinkedList"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"LinkedListNode"}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} point de départ de la chaîne à inserrer

\item[{Renvoie}] \leavevmode
noeud tête de l’insertion

\end{description}\end{quote}

:rtype:: LinkedListNode

\end{fulllineitems}

\index{insertRight() (méthode linkedlistnode.LinkedListNode)@\spxentry{insertRight()}\spxextra{méthode linkedlistnode.LinkedListNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedListNode.insertRight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insertRight}}}{\emph{toInsert: Union{[}LinkedList, LinkedListNode{]}}}{{ $\rightarrow$ linkedlistnode.LinkedListNode}}
Insert un noeud ou tout une chaîne à droite
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{toInsert}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{"LinkedList"}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"LinkedListNode"}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} point de départ de la chaîne à inserrer

\item[{Renvoie}] \leavevmode
noeud courant

\end{description}\end{quote}

:rtype:: LinkedListNode

\end{fulllineitems}

\index{next() (linkedlistnode.LinkedListNode property)@\spxentry{next()}\spxextra{linkedlistnode.LinkedListNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{linkedlistnode:linkedlistnode.LinkedListNode.next}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{next}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud suivant

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{LinkedListNode}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{litteral module}
\label{\detokenize{litteral:module-litteral}}\label{\detokenize{litteral:litteral-module}}\label{\detokenize{litteral::doc}}\index{litteral (module)@\spxentry{litteral}\spxextra{module}}\phantomsection\label{\detokenize{litteral:module-litteral}}\index{litteral (module)@\spxentry{litteral}\spxextra{module}}\index{Litteral (classe dans litteral)@\spxentry{Litteral}\spxextra{classe dans litteral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{litteral:litteral.Litteral}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{litteral.}}\sphinxbfcode{\sphinxupquote{Litteral}}}{\emph{value: int}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{isBetween() (méthode litteral.Litteral)@\spxentry{isBetween()}\spxextra{méthode litteral.Litteral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{litteral:litteral.Litteral.isBetween}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isBetween}}}{\emph{minValue: int}, \emph{maxValue: int}}{{ $\rightarrow$ bool}}
Retourne True si la valeur courante est comprise entre minValue et maxValue.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{minValue}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} valeur minimum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxValue}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} valeur maximum

\end{itemize}

\item[{Renvoie}] \leavevmode
Vrai si la valeur du littéral est compris entre minValue et maxValue, inclus

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isBetween}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isBetween}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{negClone() (méthode litteral.Litteral)@\spxentry{negClone()}\spxextra{méthode litteral.Litteral}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{litteral:litteral.Litteral.negClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{negClone}}}{}{{ $\rightarrow$ litteral.Litteral}}
Produit un clone du littéral avec valeur opposée
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone du littéral avec valeur opposée

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{Litteral}}}

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{o}{.}\PYG{n}{negClone}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{\PYGZhy{}8}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{value() (litteral.Litteral property)@\spxentry{value()}\spxextra{litteral.Litteral property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{litteral:litteral.Litteral.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
Retourne la valeur du littéral
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur du littéral

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Litteral}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{\PYGZhy{}15}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{logicexpressionnodes module}
\label{\detokenize{logicexpressionnodes:module-logicexpressionnodes}}\label{\detokenize{logicexpressionnodes:logicexpressionnodes-module}}\label{\detokenize{logicexpressionnodes::doc}}\index{logicexpressionnodes (module)@\spxentry{logicexpressionnodes}\spxextra{module}}\phantomsection\label{\detokenize{logicexpressionnodes:module-logicexpressionnodes}}\index{logicexpressionnodes (module)@\spxentry{logicexpressionnodes}\spxextra{module}}
\begin{sphinxadmonition}{note}{Note:}
Les noeuds ne sont jamais modifiés. toute modification entraîne la création de clones.
\end{sphinxadmonition}
\index{AndNode (classe dans logicexpressionnodes)@\spxentry{AndNode}\spxextra{classe dans logicexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.AndNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{logicexpressionnodes.}}\sphinxbfcode{\sphinxupquote{AndNode}}}{\emph{operand1: Union{[}LogicExpressionNode, ComparaisonExpressionNode{]}, operand2: Union{[}LogicExpressionNode, ComparaisonExpressionNode{]}}}{}
Bases : {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{logicexpressionnodes.LogicExpressionNode}}}}}
\index{clone() (méthode logicexpressionnodes.AndNode)@\spxentry{clone()}\spxextra{méthode logicexpressionnodes.AndNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.AndNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ logicexpressionnodes.LogicExpressionNode}}
Produit un clone de l’objet avec son arborescence
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{logicNegateClone() (méthode logicexpressionnodes.AndNode)@\spxentry{logicNegateClone()}\spxextra{méthode logicexpressionnodes.AndNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.AndNode.logicNegateClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logicNegateClone}}}{}{{ $\rightarrow$ Union{[}comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}}}
Complément
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud dont les l’expression est complémentaire, ou le noeud lui même si pas de changement

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, “LogicExpressionNode”{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{operands() (logicexpressionnodes.AndNode property)@\spxentry{operands()}\spxextra{logicexpressionnodes.AndNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.AndNode.operands}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operands}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
operand

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LogicExpressionNode (classe dans logicexpressionnodes)@\spxentry{LogicExpressionNode}\spxextra{classe dans logicexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{logicexpressionnodes.}}\sphinxbfcode{\sphinxupquote{LogicExpressionNode}}}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{clone() (méthode logicexpressionnodes.LogicExpressionNode)@\spxentry{clone()}\spxextra{méthode logicexpressionnodes.LogicExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ logicexpressionnodes.LogicExpressionNode}}
Crée un noeud clone
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’aborescence enfant est également clonée.
\end{sphinxadmonition}

\end{fulllineitems}

\index{logicNegateClone() (méthode logicexpressionnodes.LogicExpressionNode)@\spxentry{logicNegateClone()}\spxextra{méthode logicexpressionnodes.LogicExpressionNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode.logicNegateClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{logicNegateClone}}}{}{{ $\rightarrow$ Union{[}comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}}}
Calcul la négation logique de l’expression.
Dans le cas not, consiste à enlever le not.

Si pas un not, alors c’est un noeud arithmétique qui n’est pas modifié.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone pour obtenir une négation logique

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}{]}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Un clone est systèmatiquement créé
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{NotNode (classe dans logicexpressionnodes)@\spxentry{NotNode}\spxextra{classe dans logicexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.NotNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{logicexpressionnodes.}}\sphinxbfcode{\sphinxupquote{NotNode}}}{\emph{operand: Union{[}LogicExpressionNode, ComparaisonExpressionNode{]}}}{}
Bases : {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{logicexpressionnodes.LogicExpressionNode}}}}}
\index{clone() (méthode logicexpressionnodes.NotNode)@\spxentry{clone()}\spxextra{méthode logicexpressionnodes.NotNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.NotNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ logicexpressionnodes.LogicExpressionNode}}
Crée un noeud clone
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
L’aborescence enfant est également clonée.
\end{sphinxadmonition}

\end{fulllineitems}

\index{logicNegateClone() (méthode logicexpressionnodes.NotNode)@\spxentry{logicNegateClone()}\spxextra{méthode logicexpressionnodes.NotNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.NotNode.logicNegateClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logicNegateClone}}}{}{{ $\rightarrow$ Union{[}comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}}}
Calcul la négation logique de l’expression.
Dans le cas not, consiste à enlever le not.

Si pas un not, alors c’est un noeud arithmétique qui n’est pas modifié.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone pour obtenir une négation logique

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, “LogicExpressionNode”{]}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Un clone est systèmatiquement créé
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{arithmeticexpressionnodes} \PYG{k}{import} \PYG{n}{ValueNode}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{variable} \PYG{k}{import} \PYG{n}{Variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{litteral} \PYG{k}{import} \PYG{n}{Litteral}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oLitteral} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oVariable} \PYG{o}{=} \PYG{n}{ValueNode}\PYG{p}{(}\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oComp} \PYG{o}{=} \PYG{n}{ComparaisonExpressionNode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{oLitteral}\PYG{p}{,} \PYG{n}{oVariable}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oNot} \PYG{o}{=} \PYG{n}{NotNode}\PYG{p}{(}\PYG{n}{oComp}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{negateONot} \PYG{o}{=} \PYG{n}{oNot}\PYG{o}{.}\PYG{n}{logicNegateClone}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{negateONot}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}(\PYGZsh{}1 \PYGZlt{} @x)\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{operand() (logicexpressionnodes.NotNode property)@\spxentry{operand()}\spxextra{logicexpressionnodes.NotNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.NotNode.operand}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operand}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
operand

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OrNode (classe dans logicexpressionnodes)@\spxentry{OrNode}\spxextra{classe dans logicexpressionnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.OrNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{logicexpressionnodes.}}\sphinxbfcode{\sphinxupquote{OrNode}}}{\emph{operand1: Union{[}LogicExpressionNode, ComparaisonExpressionNode{]}, operand2: Union{[}LogicExpressionNode, ComparaisonExpressionNode{]}}}{}
Bases : {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{logicexpressionnodes.LogicExpressionNode}}}}}
\index{clone() (méthode logicexpressionnodes.OrNode)@\spxentry{clone()}\spxextra{méthode logicexpressionnodes.OrNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.OrNode.clone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{{ $\rightarrow$ logicexpressionnodes.LogicExpressionNode}}
Produit un clone de l’objet avec son arborescence
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
clone

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{logicNegateClone() (méthode logicexpressionnodes.OrNode)@\spxentry{logicNegateClone()}\spxextra{méthode logicexpressionnodes.OrNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.OrNode.logicNegateClone}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{logicNegateClone}}}{}{{ $\rightarrow$ Union{[}comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}}}
Complément
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud dont les l’expression est complémentaire, ou le noeud lui même si pas de changement

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, “LogicExpressionNode”{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{operands() (logicexpressionnodes.OrNode property)@\spxentry{operands()}\spxextra{logicexpressionnodes.OrNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{logicexpressionnodes:logicexpressionnodes.OrNode.operands}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operands}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
operand

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{parsertokens module}
\label{\detokenize{parsertokens:module-parsertokens}}\label{\detokenize{parsertokens:parsertokens-module}}\label{\detokenize{parsertokens::doc}}\index{parsertokens (module)@\spxentry{parsertokens}\spxextra{module}}\phantomsection\label{\detokenize{parsertokens:module-parsertokens}}\index{parsertokens (module)@\spxentry{parsertokens}\spxextra{module}}\index{Token (classe dans parsertokens)@\spxentry{Token}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.Token}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{Token}}}
Bases : \sphinxcode{\sphinxupquote{object}}

Classe abstraite qui ne devrait pas être instanciée
\index{getPriority() (méthode parsertokens.Token)@\spxentry{getPriority()}\spxextra{méthode parsertokens.Token}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.Token.getPriority}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getPriority}}}{}{{ $\rightarrow$ int}}
Fonction par défaut
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
priorité de l’opérateur

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{isOperand() (méthode parsertokens.Token)@\spxentry{isOperand()}\spxextra{méthode parsertokens.Token}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.Token.isOperand}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isOperand}}}{}{{ $\rightarrow$ bool}}
Le token est\sphinxhyphen{}il une opérande ?
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai le token est un nombre ou une variable

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{or}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOperand}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOperand}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{isOperator() (méthode parsertokens.Token)@\spxentry{isOperator()}\spxextra{méthode parsertokens.Token}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.Token.isOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isOperator}}}{}{{ $\rightarrow$ bool}}
Le token est\sphinxhyphen{}il une opérateur de calcul ?
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai le token est un opérateur, binaire ou unaire

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{or}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOperator}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{test() (méthode de la classe parsertokens.Token)@\spxentry{test()}\spxextra{méthode de la classe parsertokens.Token}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.Token.test}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{test}}}{\emph{expression: str}}{{ $\rightarrow$ bool}}
Chaque type de noeud est associé à une expression régulière
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{expression}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} expression à tester

\item[{Renvoie}] \leavevmode
vrai si l’expression valide l’expression régulière

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{o}{.}\PYG{n}{test}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{o}{.}\PYG{n}{test}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2 + 3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TokenBinaryOperator (classe dans parsertokens)@\spxentry{TokenBinaryOperator}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenBinaryOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{TokenBinaryOperator}}}{\emph{operator: str}}{}
Bases : {\hyperref[\detokenize{parsertokens:parsertokens.Token}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parsertokens.Token}}}}}
\index{getPriority() (méthode parsertokens.TokenBinaryOperator)@\spxentry{getPriority()}\spxextra{méthode parsertokens.TokenBinaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenBinaryOperator.getPriority}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getPriority}}}{}{{ $\rightarrow$ int}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
priorité de l’opérateur

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{or}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{and}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{|}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{6}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{operator() (parsertokens.TokenBinaryOperator property)@\spxentry{operator()}\spxextra{parsertokens.TokenBinaryOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenBinaryOperator.operator}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operator}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
opérateur

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{or}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{operator}
\PYG{g+go}{\PYGZsq{}or\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenBinaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{operator}
\PYG{g+go}{\PYGZsq{}+\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{regex (attribut parsertokens.TokenBinaryOperator)@\spxentry{regex}\spxextra{attribut parsertokens.TokenBinaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenBinaryOperator.regex}}\pysigline{\sphinxbfcode{\sphinxupquote{regex}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}\textless{}=|==|\textgreater{}=|!=|{[}\textbackslash{}\textbackslash{}\textasciicircum{}\textless{}\textgreater{}+\textbackslash{}\textbackslash{}\sphinxhyphen{}*\textbackslash{}\textbackslash{}/\%\&|{]}|and|or\textquotesingle{}}}}
\end{fulllineitems}

\index{toNode() (méthode parsertokens.TokenBinaryOperator)@\spxentry{toNode()}\spxextra{méthode parsertokens.TokenBinaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenBinaryOperator.toNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toNode}}}{\emph{operandsList: List{[}Union{[}arithmeticexpressionnodes.ArithmeticExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}{]}}}{{ $\rightarrow$ Union{[}arithmeticexpressionnodes.ArithmeticExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode, None{]}}}
Conversion en objet noeud
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operandsList}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ArithmeticExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ComparaisonExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LogicExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} opérandes enfants

\item[{Renvoie}] \leavevmode
noeud binaire expression correspondant

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}, None{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TokenNumber (classe dans parsertokens)@\spxentry{TokenNumber}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenNumber}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{TokenNumber}}}{\emph{expression}}{}
Bases : {\hyperref[\detokenize{parsertokens:parsertokens.Token}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parsertokens.Token}}}}}
\index{regex (attribut parsertokens.TokenNumber)@\spxentry{regex}\spxextra{attribut parsertokens.TokenNumber}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenNumber.regex}}\pysigline{\sphinxbfcode{\sphinxupquote{regex}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}{[}0\sphinxhyphen{}9{]}+\textquotesingle{}}}}
\end{fulllineitems}

\index{toNode() (méthode parsertokens.TokenNumber)@\spxentry{toNode()}\spxextra{méthode parsertokens.TokenNumber}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenNumber.toNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toNode}}}{}{}
Conversion en objet noeud

\begin{sphinxadmonition}{note}{Note:}
Crée un objet Litteral correspondant
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud valeur correspondant

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode}]{\sphinxcrossref{ValueNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{value() (parsertokens.TokenNumber property)@\spxentry{value()}\spxextra{parsertokens.TokenNumber property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenNumber.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenNumber}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{17}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{17}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TokenParenthesis (classe dans parsertokens)@\spxentry{TokenParenthesis}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenParenthesis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{TokenParenthesis}}}{\emph{expression}}{}
Bases : {\hyperref[\detokenize{parsertokens:parsertokens.Token}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parsertokens.Token}}}}}
\index{isOpening() (méthode parsertokens.TokenParenthesis)@\spxentry{isOpening()}\spxextra{méthode parsertokens.TokenParenthesis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenParenthesis.isOpening}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{isOpening}}}{}{{ $\rightarrow$ bool}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai si la parenthèse est ouvrante

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOpening}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenParenthesis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{isOpening}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{regex (attribut parsertokens.TokenParenthesis)@\spxentry{regex}\spxextra{attribut parsertokens.TokenParenthesis}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenParenthesis.regex}}\pysigline{\sphinxbfcode{\sphinxupquote{regex}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}\textbackslash{}\textbackslash{}(|\textbackslash{}\textbackslash{})\textquotesingle{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{TokenUnaryOperator (classe dans parsertokens)@\spxentry{TokenUnaryOperator}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenUnaryOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{TokenUnaryOperator}}}{\emph{operator: str}}{}
Bases : {\hyperref[\detokenize{parsertokens:parsertokens.Token}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parsertokens.Token}}}}}
\index{getPriority() (méthode parsertokens.TokenUnaryOperator)@\spxentry{getPriority()}\spxextra{méthode parsertokens.TokenUnaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenUnaryOperator.getPriority}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getPriority}}}{}{{ $\rightarrow$ int}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
priorité de l’opérateur

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenUnaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{not}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenUnaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZti{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getPriority}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{6}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{operator() (parsertokens.TokenUnaryOperator property)@\spxentry{operator()}\spxextra{parsertokens.TokenUnaryOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenUnaryOperator.operator}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{operator}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
opérateur

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenUnaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{not}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{operator}
\PYG{g+go}{\PYGZsq{}not\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenUnaryOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{operator}
\PYG{g+go}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{regex (attribut parsertokens.TokenUnaryOperator)@\spxentry{regex}\spxextra{attribut parsertokens.TokenUnaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenUnaryOperator.regex}}\pysigline{\sphinxbfcode{\sphinxupquote{regex}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}\textasciitilde{}|not\textquotesingle{}}}}
\end{fulllineitems}

\index{toNode() (méthode parsertokens.TokenUnaryOperator)@\spxentry{toNode()}\spxextra{méthode parsertokens.TokenUnaryOperator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenUnaryOperator.toNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toNode}}}{\emph{operandsList: List{[}Union{[}arithmeticexpressionnodes.ArithmeticExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode{]}{]}}}{{ $\rightarrow$ Union{[}arithmeticexpressionnodes.ArithmeticExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode, logicexpressionnodes.LogicExpressionNode, None{]}}}
Conversion en objet noeud
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operandsList}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ArithmeticExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ComparaisonExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LogicExpressionNode}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} opérandes enfants

\item[{Renvoie}] \leavevmode
noeud unaire ou valeur correspondant

\item[{Type renvoyé}] \leavevmode
Union{[}{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}, {\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}, {\hyperref[\detokenize{logicexpressionnodes:logicexpressionnodes.LogicExpressionNode}]{\sphinxcrossref{LogicExpressionNode}}}, None{]}

\end{description}\end{quote}

un \sphinxhyphen{} unaire sur un littéral est aussitôt convertit en l’opposé de ce littéral

\end{fulllineitems}


\end{fulllineitems}

\index{TokenVariable (classe dans parsertokens)@\spxentry{TokenVariable}\spxextra{classe dans parsertokens}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{parsertokens.}}\sphinxbfcode{\sphinxupquote{TokenVariable}}}{\emph{name}}{}
Bases : {\hyperref[\detokenize{parsertokens:parsertokens.Token}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parsertokens.Token}}}}}
\index{RESERVED\_NAMES (attribut parsertokens.TokenVariable)@\spxentry{RESERVED\_NAMES}\spxextra{attribut parsertokens.TokenVariable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable.RESERVED_NAMES}}\pysigline{\sphinxbfcode{\sphinxupquote{RESERVED\_NAMES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}and\textquotesingle{}, \textquotesingle{}or\textquotesingle{}, \textquotesingle{}not\textquotesingle{}, \textquotesingle{}while\textquotesingle{}, \textquotesingle{}if\textquotesingle{}, \textquotesingle{}else\textquotesingle{}, \textquotesingle{}elif\textquotesingle{})}}}
\end{fulllineitems}

\index{regex (attribut parsertokens.TokenVariable)@\spxentry{regex}\spxextra{attribut parsertokens.TokenVariable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable.regex}}\pysigline{\sphinxbfcode{\sphinxupquote{regex}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}{[}a\sphinxhyphen{}zA\sphinxhyphen{}Z{]}{[}a\sphinxhyphen{}zA\sphinxhyphen{}Z\_0\sphinxhyphen{}9{]}*\textquotesingle{}}}}
\end{fulllineitems}

\index{test() (méthode de la classe parsertokens.TokenVariable)@\spxentry{test()}\spxextra{méthode de la classe parsertokens.TokenVariable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable.test}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{test}}}{\emph{expression: str}}{{ $\rightarrow$ bool}}
Teste si l’expression correspond à nom de variable valide
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{expression}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} expression à tester

\item[{Renvoie}] \leavevmode
vrai si l’expression valide l’expression régulière

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{o}{.}\PYG{n}{test}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{o}{.}\PYG{n}{test}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{if}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{o}{.}\PYG{n}{test}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x+y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{toNode() (méthode parsertokens.TokenVariable)@\spxentry{toNode()}\spxextra{méthode parsertokens.TokenVariable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable.toNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{toNode}}}{}{}
Conversion en objet noeud

\begin{sphinxadmonition}{note}{Note:}
Crée un objet Variable correspondant
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
noeud valeur correspondant

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ValueNode}]{\sphinxcrossref{ValueNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{value() (parsertokens.TokenVariable property)@\spxentry{value()}\spxextra{parsertokens.TokenVariable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{parsertokens:parsertokens.TokenVariable.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{TokenVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{\PYGZsq{}x\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{processorengine module}
\label{\detokenize{processorengine:module-processorengine}}\label{\detokenize{processorengine:processorengine-module}}\label{\detokenize{processorengine::doc}}\index{processorengine (module)@\spxentry{processorengine}\spxextra{module}}\phantomsection\label{\detokenize{processorengine:module-processorengine}}\index{processorengine (module)@\spxentry{processorengine}\spxextra{module}}\index{Commands (classe dans processorengine)@\spxentry{Commands}\spxextra{classe dans processorengine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.Commands}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{processorengine.}}\sphinxbfcode{\sphinxupquote{Commands}}}
Bases : \sphinxcode{\sphinxupquote{dict}}

\end{fulllineitems}

\index{EngineAttributes (classe dans processorengine)@\spxentry{EngineAttributes}\spxextra{classe dans processorengine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.EngineAttributes}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{processorengine.}}\sphinxbfcode{\sphinxupquote{EngineAttributes}}}
Bases : \sphinxcode{\sphinxupquote{dict}}

\end{fulllineitems}

\index{ProcessorEngine (classe dans processorengine)@\spxentry{ProcessorEngine}\spxextra{classe dans processorengine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{processorengine.}}\sphinxbfcode{\sphinxupquote{ProcessorEngine}}}{\emph{name: str = \textquotesingle{}default\textquotesingle{}}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{AVAILABLE\_ENGINES (attribut processorengine.ProcessorEngine)@\spxentry{AVAILABLE\_ENGINES}\spxextra{attribut processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.AVAILABLE_ENGINES}}\pysigline{\sphinxbfcode{\sphinxupquote{AVAILABLE\_ENGINES}}\sphinxbfcode{\sphinxupquote{ = {[}(\textquotesingle{}Processeur 16 bits\textquotesingle{}, \textquotesingle{}default\textquotesingle{}), (\textquotesingle{}Processeur 12 bits\textquotesingle{}, \textquotesingle{}12bits\textquotesingle{}){]}}}}
\end{fulllineitems}

\index{dataBits() (processorengine.ProcessorEngine property)@\spxentry{dataBits()}\spxextra{processorengine.ProcessorEngine property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.dataBits}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{dataBits}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de bits utilisés pour l’encodage d’une donnée en mémoire

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dataBits}
\PYG{g+go}{16}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getAsmCommand() (méthode processorengine.ProcessorEngine)@\spxentry{getAsmCommand()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getAsmCommand}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getAsmCommand}}}{\emph{commandDesc: str}}{{ $\rightarrow$ str}}
Renvoie le nom de commande assembleur de la commande demandée. \sphinxcode{\sphinxupquote{\textquotesingle{}\textquotesingle{}}} si introuvable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de la commande

\item[{Renvoie}] \leavevmode
commande assembleur

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getAsmCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}MULT\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getAsmCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZam{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}AND\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getAsmCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getComparaisonSymbolsAvailables() (méthode processorengine.ProcessorEngine)@\spxentry{getComparaisonSymbolsAvailables()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getComparaisonSymbolsAvailables}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getComparaisonSymbolsAvailables}}}{}{{ $\rightarrow$ List{[}str{]}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
liste des symboles de comparaison disponibles avec ce modèle de processeur

\item[{Type renvoyé}] \leavevmode
list{[}str{]}

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getComparaisonSymbolsAvailables}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[\PYGZsq{}\PYGZlt{}\PYGZsq{}, \PYGZsq{}\PYGZgt{}\PYGZsq{}, \PYGZsq{}==\PYGZsq{}, \PYGZsq{}!=\PYGZsq{}]}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLitteralAsmCommand() (méthode processorengine.ProcessorEngine)@\spxentry{getLitteralAsmCommand()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getLitteralAsmCommand}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLitteralAsmCommand}}}{\emph{commandDesc: str}}{{ $\rightarrow$ str}}
Renvoie le nom de commande assembleur de la commande demandée, dans sa version acceptant un littéral. \sphinxcode{\sphinxupquote{\textquotesingle{}\textquotesingle{}}} si introuvable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de la commande

\item[{Renvoie}] \leavevmode
commande assembleur

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLitteralAsmCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}MULT\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLitteralAsmCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLitteralMaxSizeIn() (méthode processorengine.ProcessorEngine)@\spxentry{getLitteralMaxSizeIn()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getLitteralMaxSizeIn}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLitteralMaxSizeIn}}}{\emph{commandDesc: str}}{{ $\rightarrow$ int}}
Considérant une commande, détermine le nombre de bits utilisés par l’encodage des attributs de la commande et déduit le nombre de bits laissés pour le codage en nombre positif d’un éventuel littéral, et donc la taille maximal de ce littéral.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} commande à utiliser

\item[{Renvoie}] \leavevmode
valeur maximale acceptable du littéral

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLitteralMaxSizeIn}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{63}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getLitteralOpcode() (méthode processorengine.ProcessorEngine)@\spxentry{getLitteralOpcode()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getLitteralOpcode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getLitteralOpcode}}}{\emph{commandDesc: str}}{{ $\rightarrow$ str}}
Renvoie l’opcode de la commande demandée dans sa version acceptant un littéral. \sphinxcode{\sphinxupquote{\textquotesingle{}\textquotesingle{}}} si introuvable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de la commande

\item[{Renvoie}] \leavevmode
opcode sous forme binaire

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLitteralOpcode}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}1010\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getLitteralOpcode}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{getOpcode() (méthode processorengine.ProcessorEngine)@\spxentry{getOpcode()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.getOpcode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getOpcode}}}{\emph{commandDesc: str}}{{ $\rightarrow$ str}}
Renvoie l’opcode de la commande demandée. \sphinxcode{\sphinxupquote{\textquotesingle{}\textquotesingle{}}} si introuvable.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de la commande

\item[{Renvoie}] \leavevmode
opcode sous forme binaire

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getOpcode}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0110010\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getOpcode}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{hasNEG() (méthode processorengine.ProcessorEngine)@\spxentry{hasNEG()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.hasNEG}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hasNEG}}}{}{{ $\rightarrow$ bool}}
Le modèle de processeur possède\sphinxhyphen{}t\sphinxhyphen{}il un \sphinxhyphen{} unaire ?
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
vrai s’il en possède un

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hasNEG}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{12bits}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hasNEG}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{hasOperator() (méthode processorengine.ProcessorEngine)@\spxentry{hasOperator()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.hasOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hasOperator}}}{\emph{operator: str}}{{ $\rightarrow$ bool}}
Le modèle de processeur possède\sphinxhyphen{}t\sphinxhyphen{}il l’opérateur demandé ?
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{operator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} nom de l’opérateur

\item[{Renvoie}] \leavevmode
Vrai s’il le possède

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hasOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hasOperator}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{instructionDecode() (méthode processorengine.ProcessorEngine)@\spxentry{instructionDecode()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.instructionDecode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{instructionDecode}}}{\emph{binary: Union{[}int, str{]}}}{{ $\rightarrow$ Tuple{[}str, Sequence{[}int{]}, int, int{]}}}
Pour une instruction, fait le décodage en renvoyant le descriptif commande, les opérandes registres et un éventuel opérande non registre
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{binary}} (\sphinxstyleliteralemphasis{\sphinxupquote{int ou str}}) \textendash{} code binaire

\item[{Result}] \leavevmode
tuple contenant la commande, les opérandes registres et l’éventuel opérande spéciale (adresse ou littéral), \sphinxhyphen{}1 si pas de spéciale, taille en bits de l’éventuel littéral.

\item[{Type renvoyé}] \leavevmode
Tuple{[}str, Tuple{[}int{]}, int, int{]}

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{instructionDecode}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0110011001010011}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+go}{(\PYGZsq{}/\PYGZsq{}, (1, 2, 3), \PYGZhy{}1, 0)}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{litteralOperatorAvailable() (méthode processorengine.ProcessorEngine)@\spxentry{litteralOperatorAvailable()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.litteralOperatorAvailable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{litteralOperatorAvailable}}}{\emph{commandDesc: str}, \emph{litteral: litteral.Litteral}}{{ $\rightarrow$ bool}}
Teste si la commande peut s’éxécuter dans une version acceptant un littéral, avec ce littéral en particulier. Il faut que la commande accepte les littéraux et que le codage de ce littéral soit possible dans l’espace laissé par cette commande.
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{commandDesc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} commande à utiliser

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{litteral}} ({\hyperref[\detokenize{litteral:litteral.Litteral}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Litteral}}}}}) \textendash{} littéral à utiliser

\end{itemize}

\item[{Renvoie}] \leavevmode
vrai si la commande est utilisable avec ce littéral

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{litteralOperatorAvailable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{litteralOperatorAvailable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{*}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Litteral}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{regBits() (processorengine.ProcessorEngine property)@\spxentry{regBits()}\spxextra{processorengine.ProcessorEngine property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.regBits}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{regBits}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de bits utilisés pour l’encodage de l’adresse d’un registre

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{regBits}
\PYG{g+go}{3}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{registersNumber() (méthode processorengine.ProcessorEngine)@\spxentry{registersNumber()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.registersNumber}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{registersNumber}}}{}{{ $\rightarrow$ int}}
Calcul le nombre de registres considérant l’adressage disponible
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nombre de registre

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{registersNumber}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{8}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{ualOutputIsFree() (méthode processorengine.ProcessorEngine)@\spxentry{ualOutputIsFree()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.ualOutputIsFree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ualOutputIsFree}}}{}{{ $\rightarrow$ bool}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
Vrai si on peut choisir le registre de sortie de l’UAL

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ualOutputIsFree}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{12bits}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ualOutputIsFree}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{valueFitsInMemory() (méthode processorengine.ProcessorEngine)@\spxentry{valueFitsInMemory()}\spxextra{méthode processorengine.ProcessorEngine}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{processorengine:processorengine.ProcessorEngine.valueFitsInMemory}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valueFitsInMemory}}}{\emph{value: int}, \emph{posValue: bool}}{{ $\rightarrow$ bool}}
Teste si une valeur a une valeur qui pourra être codée en mémoire
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} valeur à tester

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{posValue}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} la valeur doit être codée en nombre positif

\end{itemize}

\item[{Renvoie}] \leavevmode
la valeur peut être codée en mémoire

\item[{Type renvoyé}] \leavevmode
bool

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{valueFitsInMemory}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{valueFitsInMemory}\PYG{p}{(}\PYG{l+m+mi}{60000}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ProcessorEngine}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{valueFitsInMemory}\PYG{p}{(}\PYG{l+m+mi}{60000}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{structuresnodes module}
\label{\detokenize{structuresnodes:module-structuresnodes}}\label{\detokenize{structuresnodes:structuresnodes-module}}\label{\detokenize{structuresnodes::doc}}\index{structuresnodes (module)@\spxentry{structuresnodes}\spxextra{module}}\phantomsection\label{\detokenize{structuresnodes:module-structuresnodes}}\index{structuresnodes (module)@\spxentry{structuresnodes}\spxextra{module}}\index{AffectationNode (classe dans structuresnodes)@\spxentry{AffectationNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.AffectationNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{AffectationNode}}}{\emph{lineNumber: int}, \emph{variableCible: variable.Variable}, \emph{expression: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}
\index{cible() (structuresnodes.AffectationNode property)@\spxentry{cible()}\spxextra{structuresnodes.AffectationNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.AffectationNode.cible}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{cible}}}
Accesseur : retourne la variable cible de l’affectation.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
variable cible.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{Variable}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{expression() (structuresnodes.AffectationNode property)@\spxentry{expression()}\spxextra{structuresnodes.AffectationNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.AffectationNode.expression}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{expression}}}
Accesseur : retourne l’expression dont le résultat doit être affecté à la variable cible.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression arithmétique dont le résultat doit être affecté à la variable cible.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{IfElseNode (classe dans structuresnodes)@\spxentry{IfElseNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.IfElseNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{IfElseNode}}}{\emph{ifLineNumber: int, condition: Union{[}logicexpressionnodes.LogicExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode{]}, ifChildren: List{[}structuresnodes.StructureNode{]}, elseLineNumber: int, elseChildren: List{[}structuresnodes.StructureNode{]}}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.IfNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.IfNode}}}}}

\end{fulllineitems}

\index{IfNode (classe dans structuresnodes)@\spxentry{IfNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.IfNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{IfNode}}}{\emph{lineNumber: int, condition: Union{[}logicexpressionnodes.LogicExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode{]}, children: List{[}structuresnodes.StructureNode{]}}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}

\end{fulllineitems}

\index{InputNode (classe dans structuresnodes)@\spxentry{InputNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.InputNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{InputNode}}}{\emph{lineNumber: int}, \emph{variableCible: variable.Variable}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}
\index{cible() (structuresnodes.InputNode property)@\spxentry{cible()}\spxextra{structuresnodes.InputNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.InputNode.cible}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{cible}}}
Accesseur : retourne la variable cible du input.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
variable cible.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{variable:variable.Variable}]{\sphinxcrossref{Variable}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{JumpNode (classe dans structuresnodes)@\spxentry{JumpNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.JumpNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{JumpNode}}}{\emph{lineNumber: int}, \emph{cible: structuresnodes.StructureNode}, \emph{condition: Optional{[}comparaisonexpressionnodes.ComparaisonExpressionNode{]} = None}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}
\index{cible() (structuresnodes.JumpNode property)@\spxentry{cible()}\spxextra{structuresnodes.JumpNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.JumpNode.cible}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{cible}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
cible du saut

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{StructureNode}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{getCondition() (méthode structuresnodes.JumpNode)@\spxentry{getCondition()}\spxextra{méthode structuresnodes.JumpNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.JumpNode.getCondition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getCondition}}}{}{{ $\rightarrow$ Optional{[}comparaisonexpressionnodes.ComparaisonExpressionNode{]}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
condition du saut

\item[{Type renvoyé}] \leavevmode
Optional{[}{\hyperref[\detokenize{comparaisonexpressionnodes:comparaisonexpressionnodes.ComparaisonExpressionNode}]{\sphinxcrossref{ComparaisonExpressionNode}}}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{setCible() (méthode structuresnodes.JumpNode)@\spxentry{setCible()}\spxextra{méthode structuresnodes.JumpNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.JumpNode.setCible}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setCible}}}{\emph{cible: structuresnodes.StructureNode}}{{ $\rightarrow$ None}}
Assigne une nouvelle cible
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{cible}} ({\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{StructureNode}}}}}) \textendash{} nouvelle cible

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PrintNode (classe dans structuresnodes)@\spxentry{PrintNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.PrintNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{PrintNode}}}{\emph{lineNumber: int}, \emph{expression: arithmeticexpressionnodes.ArithmeticExpressionNode}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}
\index{expression() (structuresnodes.PrintNode property)@\spxentry{expression()}\spxextra{structuresnodes.PrintNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.PrintNode.expression}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{expression}}}
Accesseur : retourne l’expression dont le résultat doit être affiché.
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
expression arithmétique dont le résultat doit être affiché.

\item[{Type renvoyé}] \leavevmode
{\hyperref[\detokenize{arithmeticexpressionnodes:arithmeticexpressionnodes.ArithmeticExpressionNode}]{\sphinxcrossref{ArithmeticExpressionNode}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SimpleNode (classe dans structuresnodes)@\spxentry{SimpleNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.SimpleNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{SimpleNode}}}{\emph{snType: str = \textquotesingle{}\textquotesingle{}}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.StructureNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.StructureNode}}}}}
\index{snType() (structuresnodes.SimpleNode property)@\spxentry{snType()}\spxextra{structuresnodes.SimpleNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.SimpleNode.snType}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{snType}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
snType

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StructureNode (classe dans structuresnodes)@\spxentry{StructureNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNode}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{StructureNode}}}
Bases : {\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{linkedlistnode.LinkedListNode}}}}}
\index{assignLabel() (méthode structuresnodes.StructureNode)@\spxentry{assignLabel()}\spxextra{méthode structuresnodes.StructureNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNode.assignLabel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assignLabel}}}{}{{ $\rightarrow$ label.Label}}
Assigne un label au noeud s’il n’en a pas déjà un
:return: label de l’item
:rtype: Label

\end{fulllineitems}

\index{label() (structuresnodes.StructureNode property)@\spxentry{label()}\spxextra{structuresnodes.StructureNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNode.label}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{label}}}
Accesseur
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
label de l’item

\item[{Type renvoyé}] \leavevmode
Optional{[}{\hyperref[\detokenize{label:label.Label}]{\sphinxcrossref{Label}}}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{labelToStr() (méthode structuresnodes.StructureNode)@\spxentry{labelToStr()}\spxextra{méthode structuresnodes.StructureNode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNode.labelToStr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{labelToStr}}}{}{{ $\rightarrow$ str}}~\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
label en str, «  » si pas de label

\item[{Type renvoyé}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{lineNumber() (structuresnodes.StructureNode property)@\spxentry{lineNumber()}\spxextra{structuresnodes.StructureNode property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNode.lineNumber}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{lineNumber}}}
Accesseur pour le numéro de ligne d’origine de cet élément
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
numéro de ligne d’origine

\item[{Type renvoyé}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StructureNodeList (classe dans structuresnodes)@\spxentry{StructureNodeList}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNodeList}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{StructureNodeList}}}{\emph{items: List{[}LinkedListNode{]}}}{}
Bases : {\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedList}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{linkedlistnode.LinkedList}}}}}
\index{delete() (méthode structuresnodes.StructureNodeList)@\spxentry{delete()}\spxextra{méthode structuresnodes.StructureNodeList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNodeList.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{\emph{nodeToDel: linkedlistnode.LinkedListNode}}{{ $\rightarrow$ bool}}
supprime l’élément node
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{nodeToDel}} ({\hyperref[\detokenize{linkedlistnode:linkedlistnode.LinkedListNode}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LinkedListNode}}}}}) \textendash{} élément à supprimer

\item[{Renvoie}] \leavevmode
suppression effectuée

\item[{Type renvoyé}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{linearize() (méthode structuresnodes.StructureNodeList)@\spxentry{linearize()}\spxextra{méthode structuresnodes.StructureNodeList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNodeList.linearize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linearize}}}{\emph{csl: List{[}str{]}}}{{ $\rightarrow$ None}}
Crée la vesion linéaire de l’ensemble de la structure
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{csl}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} liste des comparaisons permises par le processeur utilisé

\end{description}\end{quote}

\end{fulllineitems}

\index{tabulatedStr() (méthode structuresnodes.StructureNodeList)@\spxentry{tabulatedStr()}\spxextra{méthode structuresnodes.StructureNodeList}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.StructureNodeList.tabulatedStr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tabulatedStr}}}{}{}
Transtypage
:return: chaîne de caractères avec une tabulation à chaque ligne
:rtype: str

\end{fulllineitems}


\end{fulllineitems}

\index{WhileNode (classe dans structuresnodes)@\spxentry{WhileNode}\spxextra{classe dans structuresnodes}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structuresnodes:structuresnodes.WhileNode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{structuresnodes.}}\sphinxbfcode{\sphinxupquote{WhileNode}}}{\emph{lineNumber: int, condition: Union{[}logicexpressionnodes.LogicExpressionNode, comparaisonexpressionnodes.ComparaisonExpressionNode{]}, children: List{[}structuresnodes.StructureNode{]}}}{}
Bases : {\hyperref[\detokenize{structuresnodes:structuresnodes.IfNode}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{structuresnodes.IfNode}}}}}

\end{fulllineitems}



\section{variable module}
\label{\detokenize{variable:module-variable}}\label{\detokenize{variable:variable-module}}\label{\detokenize{variable::doc}}\index{variable (module)@\spxentry{variable}\spxextra{module}}\phantomsection\label{\detokenize{variable:module-variable}}\index{variable (module)@\spxentry{variable}\spxextra{module}}\index{Variable (classe dans variable)@\spxentry{Variable}\spxextra{classe dans variable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{variable:variable.Variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{variable.}}\sphinxbfcode{\sphinxupquote{Variable}}}{\emph{nom: str}, \emph{value: int = 0}}{}
Bases : \sphinxcode{\sphinxupquote{object}}
\index{getValueBinary() (méthode variable.Variable)@\spxentry{getValueBinary()}\spxextra{méthode variable.Variable}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{variable:variable.Variable.getValueBinary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getValueBinary}}}{\emph{wordSize: int}}{{ $\rightarrow$ str}}
Retourne chaîne de caractère représentant le code CA2 de self.\_value,
pour un mot de taille wordSize bits
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{wordSize}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} taille du mot binaire

\item[{Renvoie}] \leavevmode
code CA2 de la valeur initiale de la variable, sur wordSize bits

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{45}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getValueBinary}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}00101101\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{45}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getValueBinary}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}11010011\PYGZsq{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getValueBinary}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
\PYG{c}{...}
\PYG{g+gr}{errors.CompilationError}: \PYG{n}{@x : Variable de valeur trop grande !}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}

\index{name() (variable.Variable property)@\spxentry{name()}\spxextra{variable.Variable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{variable:variable.Variable.name}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{name}}}
Retourne le nom de la variable
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
nom de la variable

\item[{Type renvoyé}] \leavevmode
str

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{name}
\PYG{g+go}{\PYGZsq{}x\PYGZsq{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Avertissement:}
Il est possible que l’on crée plusieurs variables pour un même nom
\end{sphinxadmonition}

\end{fulllineitems}

\index{value() (variable.Variable property)@\spxentry{value()}\spxextra{variable.Variable property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{variable:variable.Variable.value}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{value}}}
Retourne la valeur initiale de la variable
\begin{quote}\begin{description}
\item[{Renvoie}] \leavevmode
valeur initiale de la variable

\item[{Type renvoyé}] \leavevmode
int

\item[{Example}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{0}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Variable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{o}{.}\PYG{n}{value}
\PYG{g+go}{15}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{widgets module}
\label{\detokenize{widgets:module-widgets}}\label{\detokenize{widgets:widgets-module}}\label{\detokenize{widgets::doc}}\index{widgets (module)@\spxentry{widgets}\spxextra{module}}\phantomsection\label{\detokenize{widgets:module-widgets}}\index{widgets (module)@\spxentry{widgets}\spxextra{module}}\index{BufferWidget (classe dans widgets)@\spxentry{BufferWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{BufferWidget}}}{\emph{parent}, \emph{bufferComp}, \emph{**options}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}
\index{BACKGROUND (attribut widgets.BufferWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{BUFFER\_LINES (attribut widgets.BufferWidget)@\spxentry{BUFFER\_LINES}\spxextra{attribut widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.BUFFER_LINES}}\pysigline{\sphinxbfcode{\sphinxupquote{BUFFER\_LINES}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{MAX\_BUFFER\_LENGTH (attribut widgets.BufferWidget)@\spxentry{MAX\_BUFFER\_LENGTH}\spxextra{attribut widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.MAX_BUFFER_LENGTH}}\pysigline{\sphinxbfcode{\sphinxupquote{MAX\_BUFFER\_LENGTH}}\sphinxbfcode{\sphinxupquote{ = 30}}}
\end{fulllineitems}

\index{MODES (attribut widgets.BufferWidget)@\spxentry{MODES}\spxextra{attribut widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}hex\textquotesingle{}, \textquotesingle{}dec\textquotesingle{})}}}
\end{fulllineitems}

\index{SAISIE\_COLS (attribut widgets.BufferWidget)@\spxentry{SAISIE\_COLS}\spxextra{attribut widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.SAISIE_COLS}}\pysigline{\sphinxbfcode{\sphinxupquote{SAISIE\_COLS}}\sphinxbfcode{\sphinxupquote{ = 18}}}
\end{fulllineitems}

\index{bufferize() (méthode widgets.BufferWidget)@\spxentry{bufferize()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.bufferize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bufferize}}}{\emph{evt}}{}
\end{fulllineitems}

\index{onreadempty() (méthode widgets.BufferWidget)@\spxentry{onreadempty()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.onreadempty}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onreadempty}}}{\emph{params}}{}
\end{fulllineitems}

\index{onreadwrite() (méthode widgets.BufferWidget)@\spxentry{onreadwrite()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.onreadwrite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onreadwrite}}}{\emph{params}}{}
\end{fulllineitems}

\index{refreshStrBuffer() (méthode widgets.BufferWidget)@\spxentry{refreshStrBuffer()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.refreshStrBuffer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refreshStrBuffer}}}{}{}
\end{fulllineitems}

\index{resetMessage() (méthode widgets.BufferWidget)@\spxentry{resetMessage()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.resetMessage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resetMessage}}}{}{}
\end{fulllineitems}

\index{selectMode() (méthode widgets.BufferWidget)@\spxentry{selectMode()}\spxextra{méthode widgets.BufferWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.BufferWidget.selectMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectMode}}}{\emph{mode}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{InputCodeWidget (classe dans widgets)@\spxentry{InputCodeWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{InputCodeWidget}}}{\emph{parent}, \emph{textCode}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}
\index{COLS (attribut widgets.InputCodeWidget)@\spxentry{COLS}\spxextra{attribut widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.COLS}}\pysigline{\sphinxbfcode{\sphinxupquote{COLS}}\sphinxbfcode{\sphinxupquote{ = 50}}}
\end{fulllineitems}

\index{LINES (attribut widgets.InputCodeWidget)@\spxentry{LINES}\spxextra{attribut widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.LINES}}\pysigline{\sphinxbfcode{\sphinxupquote{LINES}}\sphinxbfcode{\sphinxupquote{ = 30}}}
\end{fulllineitems}

\index{MSG\_LINES (attribut widgets.InputCodeWidget)@\spxentry{MSG\_LINES}\spxextra{attribut widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.MSG_LINES}}\pysigline{\sphinxbfcode{\sphinxupquote{MSG\_LINES}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{clearProgramInput() (méthode widgets.InputCodeWidget)@\spxentry{clearProgramInput()}\spxextra{méthode widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.clearProgramInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clearProgramInput}}}{}{}
\end{fulllineitems}

\index{highlightLine() (méthode widgets.InputCodeWidget)@\spxentry{highlightLine()}\spxextra{méthode widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.highlightLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{highlightLine}}}{\emph{lineNumber}}{}
\end{fulllineitems}

\index{textCode() (widgets.InputCodeWidget property)@\spxentry{textCode()}\spxextra{widgets.InputCodeWidget property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.textCode}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{textCode}}}
\end{fulllineitems}

\index{writeProgramInput() (méthode widgets.InputCodeWidget)@\spxentry{writeProgramInput()}\spxextra{méthode widgets.InputCodeWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.InputCodeWidget.writeProgramInput}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeProgramInput}}}{\emph{text}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{MemoryWidget (classe dans widgets)@\spxentry{MemoryWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{MemoryWidget}}}{\emph{parent}, \emph{memory}, \emph{**kwargs}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}

Panneau affichant le contenu d’une mémoire
\index{BACKGROUND (attribut widgets.MemoryWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{HL\_BACKGROUND (attribut widgets.MemoryWidget)@\spxentry{HL\_BACKGROUND}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.HL_BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{HL\_BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}orange3\textquotesingle{}}}}
\end{fulllineitems}

\index{HL\_COLOR (attribut widgets.MemoryWidget)@\spxentry{HL\_COLOR}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.HL_COLOR}}\pysigline{\sphinxbfcode{\sphinxupquote{HL\_COLOR}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{MODES (attribut widgets.MemoryWidget)@\spxentry{MODES}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}hex\textquotesingle{}, \textquotesingle{}dec\textquotesingle{})}}}
\end{fulllineitems}

\index{cols (attribut widgets.MemoryWidget)@\spxentry{cols}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.cols}}\pysigline{\sphinxbfcode{\sphinxupquote{cols}}\sphinxbfcode{\sphinxupquote{ = 30}}}
\end{fulllineitems}

\index{highlightLine() (méthode widgets.MemoryWidget)@\spxentry{highlightLine()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.highlightLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{highlightLine}}}{\emph{index: int}}{{ $\rightarrow$ None}}
Mise en surbrillance d’une ligne
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de ligne, à partir de 0

\end{description}\end{quote}

\end{fulllineitems}

\index{lineNumberFormat (attribut widgets.MemoryWidget)@\spxentry{lineNumberFormat}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.lineNumberFormat}}\pysigline{\sphinxbfcode{\sphinxupquote{lineNumberFormat}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}\{:03d\}:   \textquotesingle{}}}}
\end{fulllineitems}

\index{lines (attribut widgets.MemoryWidget)@\spxentry{lines}\spxextra{attribut widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.lines}}\pysigline{\sphinxbfcode{\sphinxupquote{lines}}\sphinxbfcode{\sphinxupquote{ = 25}}}
\end{fulllineitems}

\index{onfill() (méthode widgets.MemoryWidget)@\spxentry{onfill()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.onfill}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onfill}}}{\emph{params: Any}}{{ $\rightarrow$ None}}
Rafraichissement de l’affichage quand le composant mémoire
associé écrit à une adresse qui n’était pas encore utilisée
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}) \textendash{} paramètres liés à l’événement. Inutiles ici.

\end{description}\end{quote}

\end{fulllineitems}

\index{onread() (méthode widgets.MemoryWidget)@\spxentry{onread()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.onread}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onread}}}{\emph{params: Dict{[}str, Any{]}}}{{ $\rightarrow$ None}}
Callback pour la réaction une lecture mémoire
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} paramètres liés à l’événement. On utilise l’entier “index”

\end{description}\end{quote}

\end{fulllineitems}

\index{onwrite() (méthode widgets.MemoryWidget)@\spxentry{onwrite()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.onwrite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwrite}}}{\emph{params: Dict{[}str, Any{]}}}{{ $\rightarrow$ None}}
Callback pour la réaction une écriture mémoire
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} paramètres liés à l’événement. On utilise l’entier “index” et le DataValue “writed”

\end{description}\end{quote}

\end{fulllineitems}

\index{onwriteaddress() (méthode widgets.MemoryWidget)@\spxentry{onwriteaddress()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.onwriteaddress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwriteaddress}}}{\emph{params: Dict{[}str, Any{]}}}{{ $\rightarrow$ None}}
Callback pour la réaction à l’écriture de l’adresse
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} paramètres liés à l’événement. On utilise le DataValue “address”

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
n’a aucun effet si l’executeur n’est pas de type Memory
\end{sphinxadmonition}

\end{fulllineitems}

\index{refresh() (méthode widgets.MemoryWidget)@\spxentry{refresh()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.refresh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refresh}}}{}{{ $\rightarrow$ None}}
Rafraichissement de l’affichage, après lecture du contenu
du composant d’exécution associé

\end{fulllineitems}

\index{selectMode() (méthode widgets.MemoryWidget)@\spxentry{selectMode()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.selectMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectMode}}}{\emph{mode}}{}
Sélection du mode d’affichage
:param mode: mode choisi, parmi “dec”, “bin”, “hex”
:type mode: str

\end{fulllineitems}

\index{writeAddress() (méthode widgets.MemoryWidget)@\spxentry{writeAddress()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.writeAddress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeAddress}}}{\emph{address: executeurcomponents.DataValue}}{{ $\rightarrow$ None}}
Modifie l’adresse dans le registre adresse,
met en surbrillance la ligne à l’adresse sélectionnée
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{address}} ({\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}) \textendash{} adresse choisie

\end{description}\end{quote}

\end{fulllineitems}

\index{writeValueInLine() (méthode widgets.MemoryWidget)@\spxentry{writeValueInLine()}\spxextra{méthode widgets.MemoryWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.MemoryWidget.writeValueInLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeValueInLine}}}{\emph{value: executeurcomponents.DataValue}, \emph{index: int}}{{ $\rightarrow$ None}}
Écrire une valeur à une certaine ligne
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} ({\hyperref[\detokenize{executeurcomponents:executeurcomponents.DataValue}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DataValue}}}}}) \textendash{} valeur à écrire

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} numéro de ligne

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RegisterWidget (classe dans widgets)@\spxentry{RegisterWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{RegisterWidget}}}{\emph{parent}, \emph{register}, \emph{**kwargs}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}
\index{BACKGROUND (attribut widgets.RegisterWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{HL\_BACKGROUND (attribut widgets.RegisterWidget)@\spxentry{HL\_BACKGROUND}\spxextra{attribut widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.HL_BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{HL\_BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}orange3\textquotesingle{}}}}
\end{fulllineitems}

\index{MODES (attribut widgets.RegisterWidget)@\spxentry{MODES}\spxextra{attribut widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}hex\textquotesingle{}, \textquotesingle{}dec\textquotesingle{})}}}
\end{fulllineitems}

\index{onwrite() (méthode widgets.RegisterWidget)@\spxentry{onwrite()}\spxextra{méthode widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.onwrite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwrite}}}{\emph{params}}{}
\end{fulllineitems}

\index{refresh() (méthode widgets.RegisterWidget)@\spxentry{refresh()}\spxextra{méthode widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.refresh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refresh}}}{}{}
\end{fulllineitems}

\index{selectMode() (méthode widgets.RegisterWidget)@\spxentry{selectMode()}\spxextra{méthode widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.selectMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectMode}}}{\emph{mode}}{}
\end{fulllineitems}

\index{writeValue() (méthode widgets.RegisterWidget)@\spxentry{writeValue()}\spxextra{méthode widgets.RegisterWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.RegisterWidget.writeValue}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writeValue}}}{\emph{value}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{ScreenWidget (classe dans widgets)@\spxentry{ScreenWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{ScreenWidget}}}{\emph{parent}, \emph{screen}, \emph{**options}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}
\index{BACKGROUND (attribut widgets.ScreenWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{MODES (attribut widgets.ScreenWidget)@\spxentry{MODES}\spxextra{attribut widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}hex\textquotesingle{}, \textquotesingle{}dec\textquotesingle{})}}}
\end{fulllineitems}

\index{SCREEN\_COLS (attribut widgets.ScreenWidget)@\spxentry{SCREEN\_COLS}\spxextra{attribut widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.SCREEN_COLS}}\pysigline{\sphinxbfcode{\sphinxupquote{SCREEN\_COLS}}\sphinxbfcode{\sphinxupquote{ = 18}}}
\end{fulllineitems}

\index{SCREEN\_LINES (attribut widgets.ScreenWidget)@\spxentry{SCREEN\_LINES}\spxextra{attribut widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.SCREEN_LINES}}\pysigline{\sphinxbfcode{\sphinxupquote{SCREEN\_LINES}}\sphinxbfcode{\sphinxupquote{ = 5}}}
\end{fulllineitems}

\index{addLine() (méthode widgets.ScreenWidget)@\spxentry{addLine()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.addLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addLine}}}{\emph{line}}{}
\end{fulllineitems}

\index{clearScreen() (méthode widgets.ScreenWidget)@\spxentry{clearScreen()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.clearScreen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clearScreen}}}{\emph{evt}}{}
\end{fulllineitems}

\index{onclear() (méthode widgets.ScreenWidget)@\spxentry{onclear()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.onclear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onclear}}}{\emph{params}}{}
\end{fulllineitems}

\index{onwrite() (méthode widgets.ScreenWidget)@\spxentry{onwrite()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.onwrite}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwrite}}}{\emph{params}}{}
\end{fulllineitems}

\index{refresh() (méthode widgets.ScreenWidget)@\spxentry{refresh()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.refresh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refresh}}}{}{}
\end{fulllineitems}

\index{selectMode() (méthode widgets.ScreenWidget)@\spxentry{selectMode()}\spxextra{méthode widgets.ScreenWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.ScreenWidget.selectMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectMode}}}{\emph{mode}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{SimulationWidget (classe dans widgets)@\spxentry{SimulationWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{SimulationWidget}}}{\emph{parent}, \emph{parentWidget}, \emph{executeur}, \emph{textCode}, \emph{asm}, \emph{mode}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.Frame}}
\index{addMessage() (méthode widgets.SimulationWidget)@\spxentry{addMessage()}\spxextra{méthode widgets.SimulationWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.addMessage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{addMessage}}}{\emph{message}}{}
\end{fulllineitems}

\index{highlightCodeLine() (méthode widgets.SimulationWidget)@\spxentry{highlightCodeLine()}\spxextra{méthode widgets.SimulationWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.highlightCodeLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{highlightCodeLine}}}{\emph{currentAsmLine: int}}{{ $\rightarrow$ None}}
pour un numéro de ligne en mémoire, trouve  le numéro
de la ligne correspondante dans le programme d’origine et
le met en surbrillance

\end{fulllineitems}

\index{selectDisplay() (méthode widgets.SimulationWidget)@\spxentry{selectDisplay()}\spxextra{méthode widgets.SimulationWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.selectDisplay}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectDisplay}}}{\emph{mode}}{}
\end{fulllineitems}

\index{show() (méthode widgets.SimulationWidget)@\spxentry{show()}\spxextra{méthode widgets.SimulationWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.show}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{show}}}{}{}
\end{fulllineitems}

\index{stepRun() (méthode widgets.SimulationWidget)@\spxentry{stepRun()}\spxextra{méthode widgets.SimulationWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.stepRun}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stepRun}}}{}{}
\end{fulllineitems}

\index{textCode() (widgets.SimulationWidget property)@\spxentry{textCode()}\spxextra{widgets.SimulationWidget property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.SimulationWidget.textCode}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{textCode}}}
\end{fulllineitems}


\end{fulllineitems}

\index{TextWidget (classe dans widgets)@\spxentry{TextWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{TextWidget}}}{\emph{parent}, \emph{text}, \emph{**kwargs}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.Frame}}

Panneau affichant un texte avec possibilité de mettre
une ligne en surbrillance, de numéroter les lignes
\index{BACKGROUND (attribut widgets.TextWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{HL\_BACKGROUND (attribut widgets.TextWidget)@\spxentry{HL\_BACKGROUND}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.HL_BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{HL\_BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}orange3\textquotesingle{}}}}
\end{fulllineitems}

\index{HL\_COLOR (attribut widgets.TextWidget)@\spxentry{HL\_COLOR}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.HL_COLOR}}\pysigline{\sphinxbfcode{\sphinxupquote{HL\_COLOR}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{MIN\_TAB\_SIZE (attribut widgets.TextWidget)@\spxentry{MIN\_TAB\_SIZE}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.MIN_TAB_SIZE}}\pysigline{\sphinxbfcode{\sphinxupquote{MIN\_TAB\_SIZE}}\sphinxbfcode{\sphinxupquote{ = 3}}}
\end{fulllineitems}

\index{clear() (méthode widgets.TextWidget)@\spxentry{clear()}\spxextra{méthode widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{{ $\rightarrow$ None}}
Efface le contenu du texte

\end{fulllineitems}

\index{clearHighlight() (méthode widgets.TextWidget)@\spxentry{clearHighlight()}\spxextra{méthode widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.clearHighlight}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clearHighlight}}}{}{{ $\rightarrow$ None}}
Annule toute surbrillance

\end{fulllineitems}

\index{cols (attribut widgets.TextWidget)@\spxentry{cols}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.cols}}\pysigline{\sphinxbfcode{\sphinxupquote{cols}}\sphinxbfcode{\sphinxupquote{ = 30}}}
\end{fulllineitems}

\index{highlightLine() (méthode widgets.TextWidget)@\spxentry{highlightLine()}\spxextra{méthode widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.highlightLine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{highlightLine}}}{\emph{lineIndex: int}}{{ $\rightarrow$ None}}~\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{lineIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} ligne à mettre en surbrillance

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
la première ligne a l’index 0
\end{sphinxadmonition}

\end{fulllineitems}

\index{insert() (méthode widgets.TextWidget)@\spxentry{insert()}\spxextra{méthode widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.insert}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert}}}{\emph{text: str}}{{ $\rightarrow$ None}}
Ajoute un texte à la suite
\begin{quote}\begin{description}
\item[{Paramètres}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{text}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} texte à ajouter

\end{description}\end{quote}

\end{fulllineitems}

\index{lineNumberFormat (attribut widgets.TextWidget)@\spxentry{lineNumberFormat}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.lineNumberFormat}}\pysigline{\sphinxbfcode{\sphinxupquote{lineNumberFormat}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}\{:03d\}:   \textquotesingle{}}}}
\end{fulllineitems}

\index{lineNumberOffset (attribut widgets.TextWidget)@\spxentry{lineNumberOffset}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.lineNumberOffset}}\pysigline{\sphinxbfcode{\sphinxupquote{lineNumberOffset}}\sphinxbfcode{\sphinxupquote{ = 0}}}
\end{fulllineitems}

\index{lines (attribut widgets.TextWidget)@\spxentry{lines}\spxextra{attribut widgets.TextWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.lines}}\pysigline{\sphinxbfcode{\sphinxupquote{lines}}\sphinxbfcode{\sphinxupquote{ = 25}}}
\end{fulllineitems}

\index{text() (widgets.TextWidget property)@\spxentry{text()}\spxextra{widgets.TextWidget property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.TextWidget.text}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{text}}}
Accesseur
:return: texte en cours d’affichage
:rtype: str

\end{fulllineitems}


\end{fulllineitems}

\index{UalWidget (classe dans widgets)@\spxentry{UalWidget}\spxextra{classe dans widgets}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{widgets.}}\sphinxbfcode{\sphinxupquote{UalWidget}}}{\emph{parent}, \emph{ual}, \emph{**kwargs}}{}
Bases : \sphinxcode{\sphinxupquote{tkinter.LabelFrame}}
\index{BACKGROUND (attribut widgets.UalWidget)@\spxentry{BACKGROUND}\spxextra{attribut widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.BACKGROUND}}\pysigline{\sphinxbfcode{\sphinxupquote{BACKGROUND}}\sphinxbfcode{\sphinxupquote{ = \textquotesingle{}white\textquotesingle{}}}}
\end{fulllineitems}

\index{MODES (attribut widgets.UalWidget)@\spxentry{MODES}\spxextra{attribut widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.MODES}}\pysigline{\sphinxbfcode{\sphinxupquote{MODES}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}bin\textquotesingle{}, \textquotesingle{}hex\textquotesingle{}, \textquotesingle{}dec\textquotesingle{})}}}
\end{fulllineitems}

\index{oncalc() (méthode widgets.UalWidget)@\spxentry{oncalc()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.oncalc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{oncalc}}}{\emph{params}}{}
\end{fulllineitems}

\index{onsetoperation() (méthode widgets.UalWidget)@\spxentry{onsetoperation()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.onsetoperation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onsetoperation}}}{\emph{params}}{}
\end{fulllineitems}

\index{onwriteop1() (méthode widgets.UalWidget)@\spxentry{onwriteop1()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.onwriteop1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwriteop1}}}{\emph{params}}{}
\end{fulllineitems}

\index{onwriteop2() (méthode widgets.UalWidget)@\spxentry{onwriteop2()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.onwriteop2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{onwriteop2}}}{\emph{params}}{}
\end{fulllineitems}

\index{refresh() (méthode widgets.UalWidget)@\spxentry{refresh()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.refresh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refresh}}}{}{}
\end{fulllineitems}

\index{selectMode() (méthode widgets.UalWidget)@\spxentry{selectMode()}\spxextra{méthode widgets.UalWidget}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{widgets:widgets.UalWidget.selectMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{selectMode}}}{\emph{mode}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Index des modules Python}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{a}
\item\relax\sphinxstyleindexentry{arithmeticexpressionnodes}\sphinxstyleindexpageref{arithmeticexpressionnodes:\detokenize{module-arithmeticexpressionnodes}}
\item\relax\sphinxstyleindexentry{assembleurconainer}\sphinxstyleindexpageref{assembleurcontainer:\detokenize{module-assembleurconainer}}
\item\relax\sphinxstyleindexentry{assembleurcontainer}\sphinxstyleindexpageref{assembleurcontainer:\detokenize{module-assembleurcontainer}}
\item\relax\sphinxstyleindexentry{assembleurlines}\sphinxstyleindexpageref{assembleurlines:\detokenize{module-assembleurlines}}
\indexspace
\bigletter{c}
\item\relax\sphinxstyleindexentry{codeparser}\sphinxstyleindexpageref{codeparser:\detokenize{module-codeparser}}
\item\relax\sphinxstyleindexentry{comparaisonexpressionnodes}\sphinxstyleindexpageref{comparaisonexpressionnodes:\detokenize{module-comparaisonexpressionnodes}}
\item\relax\sphinxstyleindexentry{comparaisonexpressionodes}\sphinxstyleindexpageref{comparaisonexpressionnodes:\detokenize{module-comparaisonexpressionodes}}
\item\relax\sphinxstyleindexentry{compileexpressionmanager}\sphinxstyleindexpageref{compileexpressionmanager:\detokenize{module-compileexpressionmanager}}
\item\relax\sphinxstyleindexentry{compilemanager}\sphinxstyleindexpageref{compilemanager:\detokenize{module-compilemanager}}
\indexspace
\bigletter{e}
\item\relax\sphinxstyleindexentry{errors}\sphinxstyleindexpageref{errors:\detokenize{module-errors}}
\item\relax\sphinxstyleindexentry{example}\sphinxstyleindexpageref{example:\detokenize{module-example}}
\item\relax\sphinxstyleindexentry{executeur}\sphinxstyleindexpageref{executeur:\detokenize{module-executeur}}
\item\relax\sphinxstyleindexentry{executeurcomponents}\sphinxstyleindexpageref{executeurcomponents:\detokenize{module-executeurcomponents}}
\item\relax\sphinxstyleindexentry{expressionparser}\sphinxstyleindexpageref{expressionparser:\detokenize{module-expressionparser}}
\indexspace
\bigletter{g}
\item\relax\sphinxstyleindexentry{graphic}\sphinxstyleindexpageref{graphic:\detokenize{module-graphic}}
\indexspace
\bigletter{l}
\item\relax\sphinxstyleindexentry{label}\sphinxstyleindexpageref{label:\detokenize{module-label}}
\item\relax\sphinxstyleindexentry{lineparser}\sphinxstyleindexpageref{lineparser:\detokenize{module-lineparser}}
\item\relax\sphinxstyleindexentry{linkedlistnode}\sphinxstyleindexpageref{linkedlistnode:\detokenize{module-linkedlistnode}}
\item\relax\sphinxstyleindexentry{litteral}\sphinxstyleindexpageref{litteral:\detokenize{module-litteral}}
\item\relax\sphinxstyleindexentry{logicexpressionnodes}\sphinxstyleindexpageref{logicexpressionnodes:\detokenize{module-logicexpressionnodes}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{parsertokens}\sphinxstyleindexpageref{parsertokens:\detokenize{module-parsertokens}}
\item\relax\sphinxstyleindexentry{processorengine}\sphinxstyleindexpageref{processorengine:\detokenize{module-processorengine}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{structuresnodes}\sphinxstyleindexpageref{structuresnodes:\detokenize{module-structuresnodes}}
\indexspace
\bigletter{v}
\item\relax\sphinxstyleindexentry{variable}\sphinxstyleindexpageref{variable:\detokenize{module-variable}}
\indexspace
\bigletter{w}
\item\relax\sphinxstyleindexentry{widgets}\sphinxstyleindexpageref{widgets:\detokenize{module-widgets}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}